@deftypefn  {Function File} {[@var{t}, @var{y}] =} ode12 (@var{fun}, @var{trange}, @var{init})
@deftypefnx {Function File} {[@var{t}, @var{y}] =} ode12 (@var{fun}, @var{trange}, @var{init}, @var{ode_opt})
@deftypefnx {Function File} {[@var{t}, @var{y}] =} ode12 (@dots{}, @var{par1}, @var{par2}, @dots{})
@deftypefnx {Function File} {[@var{t}, @var{y}, @var{te}, @var{ye}, @var{ie}] =} ode12 (@dots{})
@deftypefnx {Function File} {@var{solution} =} ode12 (@dots{})

Solve a set of non-stiff Ordinary Differential Equations (non-stiff ODEs)
with the well known explicit Heun-Euler method of order 1.  For the
definition of this method see
@url{http://en.wikipedia.org/wiki/List_of_Runge%E2%80%93Kutta_methods}.

@var{fun} is a function handle, inline function, or string containing the
name of the function that defines the ODE: @code{y' = f(t,y)}.  The function
must accept two inputs where the first is time @var{t} and the second is a
column vector of unknowns @var{y}.

@var{trange} specifies the time interval over which the ODE will be
evaluated.  Typically, it is a two-element vector specifying the initial and
final times (@code{[tinit, tfinal]}).  If there are more than two elements
then the solution will also be evaluated at these intermediate time
instances using an interpolation procedure of the same order as the one of
the solver.

By default, @code{ode12} uses an adaptive timestep with the
@code{integrate_adaptive} algorithm.  The tolerance for the timestep
computation may be changed by using the options @code{"RelTol"}
and @code{"AbsTol"}.

@var{init} contains the initial value for the unknowns.  If it is a row
vector then the solution @var{y} will be a matrix in which each column is
the solution for the corresponding initial value in @var{init}.

The optional fourth argument @var{ode_opt} specifies non-default options to
the ODE solver. It is a structure generated by @code{odeset}.  @code{ode12}
will ignore the following options: "BDF", "InitialSlope", "Jacobian",
"JPattern", "MassSingular", "MaxOrder", "MvPattern", "Vectorized".

The function typically returns two outputs.  Variable @var{t} is a
column vector and contains the times where the solution was computed.  The
output @var{y} is a matrix in which each column refers to a different
unknown of the problem and each row corresponds to a time in @var{t}.  If
@var{trange} specifies intermediate time steps, only those will be returned.

The output can also be returned as a structure @var{solution} which
has a field @var{x} containing a row vector of times where the solution
was evaluated and a field @var{y} containing the solution matrix such
that each column corresponds to a time in @var{x}.
Use @code{fieldnames (@var{solution})} to see the other fields and
additional information returned.

If using the @code{"Events"} option then three additional outputs may
be returned.  @var{te} holds the time when an Event function returned a
zero.  @var{ye} holds the value of the solution at time @var{te}.  @var{ie}
contains an index indicating which Event function was triggered in the case
of multiple Event functions.

Example: Solve the Van der Pol equation

@example
@group
fvdp = @@(@var{t},@var{y}) [@var{y}(2); (1 - @var{y}(1)^2) * @var{y}(2) - @var{y}(1)];
[@var{t},@var{y}] = ode12 (fvdp, [0, 20], [2, 0]);
@end group
@end example
@c @seealso{odeset, ode23, ode45, ode78}
@end deftypefn

@deftypefn  {} {[@var{t}, @var{y}] =} ode23d (@var{fun}, @var{trange}, @var{init}, @var{lags}, @var{history})
@deftypefnx {} {[@var{t}, @var{y}] =} ode23d (@var{fun}, @var{trange}, @var{init}, @var{lags}, @var{history}, @var{ode_opt})
@deftypefnx {} {[@var{t}, @var{y}, @var{te}, @var{ye}, @var{ie}] =} ode23d (@dots{})
@deftypefnx {} {@var{solution} =} ode23d (@dots{})

This function file can be used to solve a set of non--stiff delay
differential equations (non--stiff DDEs) with a modified version of the well
known explicit Runge--Kutta method of order 3.

@var{fun} is a function handle, inline function, or string containing the
name of the function that defines the ODE: @code{y' = f(t,y)}.  The function
must accept two inputs where the first is time @var{t} and the second is a
column vector of unknowns @var{y}.

@var{trange} specifies the time interval over which the ODE will be
evaluated.  Typically, it is a two-element vector specifying the initial and
final times (@code{[tinit, tfinal]}).  If there are more than two elements
then the solution will also be evaluated at these intermediate time
instances using an interpolation procedure of the same order as the one of
the solver.

@var{init} contains the initial value for the unknowns.  If it is a row
vector then the solution @var{y} will be a matrix in which each column is
the solution for the corresponding initial value in @var{init}.

@var{lags} is a vector that describes the lags of time.

@var{history} is a matrix and describes the history of the DDEs.

The optional fourth argument @var{ode_opt} specifies non-default options to
the ODE solver. It is a structure generated by @code{odeset}. @code{ode23d}
will ignore the following options: "BDF", "InitialSlope", "Jacobian",
"JPattern", "MassSingular", "MaxOrder", "MvPattern", "Vectorized".

The function typically returns two outputs.  Variable @var{t} is a
column vector and contains the times where the solution was computed.  The
output @var{y} is a matrix in which each column refers to a different
unknown of the problem and each row corresponds to a time in @var{t}.  If
@var{trange} specifies intermediate time steps, only those will be returned.

The output can also be returned as a structure @var{solution} which
has field @var{x} containing the time where the solution was evaluated and
field @var{y} containing the solution matrix for the times in @var{x}.
Use @code{fieldnames (@var{solution})} to see the other fields and
additional information returned.

If using the @code{"Events"} option then three additional outputs may
be returned.  @var{te} holds the time when an Event function returned a
zero.  @var{ye} holds the value of the solution at time @var{te}.  @var{ie}
contains an index indicating which Event function was triggered in the case
of multiple Event functions.

In other words, this function will solve a problem of the form
@example
dy/dt = fun (t, y(t), y(t-lags(1), y(t-lags(2), @dots{})))
y(slot(1)) = init
y(slot(1)-lags(1)) = hist(1), y(slot(1)-lags(2)) = hist(2), @dots{}
@end example

For example:
@itemize @minus
@item
the following code solves an anonymous implementation of a chaotic behavior

@example
fcao = @@(vt, vy, vz) [2 * vz / (1 + vz^9.65) - vy];

vopt = odeset ("NormControl", "on", "RelTol", 1e-3);
vsol = ode23d (fcao, [0, 100], 0.5, 2, 0.5, vopt);

vlag = interp1 (vsol.x, vsol.y, vsol.x - 2);
plot (vsol.y, vlag); legend ("fcao (t,y,z)");
@end example

@item
to solve the following problem with two delayed state variables

@example
d y1(t)/dt = -y1(t)
d y2(t)/dt = -y2(t) + y1(t-5)
d y3(t)/dt = -y3(t) + y2(t-10)*y1(t-10)
@end example

one might do the following

@example
function f = fun (t, y, yd)
f(1) = -y(1);                   %% y1' = -y1(t)
f(2) = -y(2) + yd(1,1);         %% y2' = -y2(t) + y1(t-lags(1))
f(3) = -y(3) + yd(2,2)*yd(1,2); %% y3' = -y3(t) + y2(t-lags(2))*y1(t-lags(2))
end
T = [0,20]
res = ode23d (@@fun, T, [1;1;1], [5, 10], ones (3,2));
@end example

@end itemize
@c @seealso{odeset, ode45d, ode78d}
@end deftypefn

@deftypefn  {Function File} {[@var{t}, @var{y}] =} ode23s (@var{fun}, @var{trange}, @var{init})
@deftypefnx {Function File} {[@var{t}, @var{y}] =} ode23s (@var{fun}, @var{trange}, @var{init}, @var{ode_opt})
@deftypefnx {Function File} {[@var{t}, @var{y}] =} ode23s (@dots{}, @var{par1}, @var{par2}, @dots{})
@deftypefnx {Function File} {[@var{t}, @var{y}, @var{te}, @var{ye}, @var{ie}] =} ode23s (@dots{})
@deftypefnx {Function File} {@var{solution} =} ode23s (@dots{})

Solve a set of stiff ordinary differential (stiff ODEs) equations with a
Rosenbrock method of order (2,3). For the definition of this method see
"The MATLAB ode suite", L.F. Shampine, mass.W. Reichelt, pp.6-7

@var{fun} is a function handle, inline function, or string containing the
name of the function that defines the ODE: @code{M y' = f(t,y)}.  The function
must accept two inputs where the first is time @var{t} and the second is a
column vector of unknowns @var{y}. @var{M} is a costant mass matrix,
non-singular and possibly sparse. Set the field @var{Mass} in @var{odeopts}
using @var{odeset} to specify a mass matrix.

@var{trange} specifies the time interval over which the ODE will be
evaluated.  Typically, it is a two-element vector specifying the initial and
final times (@code{[tinit, tfinal]}).  If there are more than two elements
then the solution will also be evaluated at these intermediate time
instances using an interpolation procedure of the same order as the one of
the solver.

By default, @code{ode23s} uses an adaptive timestep with the
@code{integrate_adaptive} algorithm.  The tolerance for the timestep
computation may be changed by using the options @code{"RelTol"}
and @code{"AbsTol"}.

@var{init} contains the initial value for the unknowns.  If it is a row
vector then the solution @var{y} will be a matrix in which each column is
the solution for the corresponding initial value in @var{init}.

The optional fourth argument @var{ode_opt} specifies non-default options to
the ODE solver. It is a structure generated by @code{odeset}.  @code{ode23s}
will ignore the following options: "BDF", "InitialSlope", "MassSingular",
"MStateDependence", "MvPattern", "MaxOrder", "NonNegative".

The function typically returns two outputs.  Variable @var{t} is a
column vector and contains the times where the solution was computed.  The
output @var{y} is a matrix in which each column refers to a different
unknown of the problem and each row corresponds to a time in @var{t}.  If
@var{trange} specifies intermediate time steps, only those will be returned.

The output can also be returned as a structure @var{solution} which
has a field @var{x} containing a row vector of times where the solution
was evaluated and a field @var{y} containing the solution matrix such
that each column corresponds to a time in @var{x}.
Use @code{fieldnames (@var{solution})} to see the other fields and
additional information returned.

If using the @code{"Events"} option then three additional outputs may
be returned.  @var{te} holds the time when an Event function returned a
zero.  @var{ye} holds the value of the solution at time @var{te}.  @var{ie}
contains an index indicating which Event function was triggered in the case
of multiple Event functions.

Example: Solve the stiff Van der Pol equation

@example
@group
f = @@(@var{t},@var{y}) [@var{y}(2); 1000*(1 - @var{y}(1)^2) * @var{y}(2) - @var{y}(1)];
opt = odeset ('Mass', [1 0; 0 1], 'MaxStep', 1e-1);
[vt, vy] = ode23s (f, [0 2000], [2 0], opt);
@end group
@end example
@c @seealso{odeset, daspk, dassl}
@end deftypefn

@deftypefn  {} {[@var{t}, @var{y}] =} ode45d (@var{fun}, @var{trange}, @var{init}, @var{lags}, @var{history})
@deftypefnx {} {[@var{t}, @var{y}] =} ode45d (@var{fun}, @var{trange}, @var{init}, @var{lags}, @var{history}, @var{ode_opt})
@deftypefnx {} {[@var{t}, @var{y}, @var{te}, @var{ye}, @var{ie}] =} ode45d (@dots{})
@deftypefnx {} {@var{solution} =} ode45d (@dots{})

Solve a set of non--stiff delay differential equations (non--stiff DDEs) with
a modified version of the well known explicit Runge--Kutta method of order
(4,5).

@var{fun} is a function handle, inline function, or string containing the
name of the function that defines the ODE: @code{y' = f(t,y)}.  The function
must accept two inputs where the first is time @var{t} and the second is a
column vector of unknowns @var{y}.

@var{trange} specifies the time interval over which the ODE will be
evaluated.  Typically, it is a two-element vector specifying the initial and
final times (@code{[tinit, tfinal]}).  If there are more than two elements
then the solution will also be evaluated at these intermediate time
instances using an interpolation procedure of the same order as the one of
the solver.

@var{init} contains the initial value for the unknowns.  If it is a row
vector then the solution @var{y} will be a matrix in which each column is
the solution for the corresponding initial value in @var{init}.

@var{lags} is a vector that describes the lags of time.

@var{history} is a matrix and describes the history of the DDEs.

The optional fourth argument @var{ode_opt} specifies non-default options to
the ODE solver. It is a structure generated by @code{odeset}. @code{ode45d}
will ignore the following options: "BDF", "InitialSlope", "Jacobian",
"JPattern", "MassSingular", "MaxOrder", "MvPattern", "Vectorized".

The function typically returns two outputs.  Variable @var{t} is a
column vector and contains the times where the solution was computed.  The
output @var{y} is a matrix in which each column refers to a different
unknown of the problem and each row corresponds to a time in @var{t}.  If
@var{trange} specifies intermediate time steps, only those will be returned.

The output can also be returned as a structure @var{solution} which
has field @var{x} containing the time where the solution was evaluated and
field @var{y} containing the solution matrix for the times in @var{x}.
Use @code{fieldnames (@var{solution})} to see the other fields and
additional information returned.

If using the @code{"Events"} option then three additional outputs may
be returned.  @var{te} holds the time when an Event function returned a
zero.  @var{ye} holds the value of the solution at time @var{te}.  @var{ie}
contains an index indicating which Event function was triggered in the case
of multiple Event functions.

In other words, this function will solve a problem of the form
@example
dy/dt = fun (t, y(t), y(t-lags(1), y(t-lags(2), @dots{})))
y(slot(1)) = init
y(slot(1)-lags(1)) = hist(1), y(slot(1)-lags(2)) = hist(2), @dots{}
@end example

For example:
@itemize @minus
@item
the following code solves an anonymous implementation of a chaotic behavior

@example
fcao = @@(vt, vy, vz) [2 * vz / (1 + vz^9.65) - vy];

vopt = odeset ("NormControl", "on", "RelTol", 1e-3);
vsol = ode45d (fcao, [0, 100], 0.5, 2, 0.5, vopt);

vlag = interp1 (vsol.x, vsol.y, vsol.x - 2);
plot (vsol.y, vlag); legend ("fcao (t,y,z)");
@end example

@item
to solve the following problem with two delayed state variables

@example
d y1(t)/dt = -y1(t)
d y2(t)/dt = -y2(t) + y1(t-5)
d y3(t)/dt = -y3(t) + y2(t-10)*y1(t-10)
@end example

one might do the following

@example
function f = fun (t, y, yd)
f(1) = -y(1);                   %% y1' = -y1(t)
f(2) = -y(2) + yd(1,1);         %% y2' = -y2(t) + y1(t-lags(1))
f(3) = -y(3) + yd(2,2)*yd(1,2); %% y3' = -y3(t) + y2(t-lags(2))*y1(t-lags(2))
end
T = [0,20]
res = ode45d (@@fun, T, [1;1;1], [5, 10], ones (3,2));
@end example

@end itemize
@c @seealso{odeset, ode23d, ode78d}
@end deftypefn

@deftypefn  {Function File} {[@var{t}, @var{y}] =} ode78 (@var{fun}, @var{trange}, @var{init})
@deftypefnx {Function File} {[@var{t}, @var{y}] =} ode78 (@var{fun}, @var{trange}, @var{init}, @var{ode_opt})
@deftypefnx {Function File} {[@var{t}, @var{y}] =} ode78 (@dots{}, @var{par1}, @var{par2}, @dots{})
@deftypefnx {Function File} {[@var{t}, @var{y}, @var{te}, @var{ye}, @var{ie}] =} ode78 (@dots{})
@deftypefnx {Function File} {@var{solution} =} ode78 (@dots{})

Solve a set of non-stiff Ordinary Differential Equations (non-stiff ODEs) or
non--stiff differential algebraic equations (non--stiff DAEs) with the well
known explicit Runge--Kutta method of order 7.

@var{fun} is a function handle, inline function, or string containing the
name of the function that defines the ODE: @code{y' = f(t,y)}.  The function
must accept two inputs where the first is time @var{t} and the second is a
column vector of unknowns @var{y}.

@var{trange} specifies the time interval over which the ODE will be
evaluated.  Typically, it is a two-element vector specifying the initial and
final times (@code{[tinit, tfinal]}).  If there are more than two elements
then the solution will also be evaluated at these intermediate time
instances using a Hermite interpolation procedure of order 3.

By default, @code{ode78} uses an adaptive timestep with the
@code{integrate_adaptive} algorithm.  The tolerance for the timestep
computation may be changed by using the options @code{"RelTol"}
and @code{"AbsTol"}.

@var{init} contains the initial value for the unknowns.  If it is a row
vector then the solution @var{y} will be a matrix in which each column is
the solution for the corresponding initial value in @var{init}.

The optional fourth argument @var{ode_opt} specifies non-default options to
the ODE solver. It is a structure generated by @code{odeset}.  @code{ode78}
will ignore the following options: "BDF", "InitialSlope", "Jacobian",
"JPattern", "MassSingular", "MaxOrder", "MvPattern", "Vectorized".

The function typically returns two outputs.  Variable @var{t} is a
column vector and contains the times where the solution was computed.  The
output @var{y} is a matrix in which each column refers to a different
unknown of the problem and each row corresponds to a time in @var{t}.  If
@var{trange} specifies intermediate time steps, only those will be returned.

The output can also be returned as a structure @var{solution} which
has a field @var{x} containing a row vector of times where the solution
was evaluated and a field @var{y} containing the solution matrix such
that each column corresponds to a time in @var{x}.
Use @code{fieldnames (@var{solution})} to see the other fields and
additional information returned.

If using the @code{"Events"} option then three additional outputs may
be returned.  @var{te} holds the time when an Event function returned a
zero.  @var{ye} holds the value of the solution at time @var{te}.  @var{ie}
contains an index indicating which Event function was triggered in the case
of multiple Event functions.

Example: Solve the Van der Pol equation

@example
@group
fvdp = @@(@var{t},@var{y}) [@var{y}(2); (1 - @var{y}(1)^2) * @var{y}(2) - @var{y}(1)];
[@var{t},@var{y}] = ode78 (fvdp, [0, 20], [2, 0]);
@end group
@end example
@c @seealso{odeset, ode78, ode23, ode78}
@end deftypefn

@deftypefn  {} {[@var{t}, @var{y}] =} ode78d (@var{fun}, @var{trange}, @var{init}, @var{lags}, @var{history})
@deftypefnx {} {[@var{t}, @var{y}] =} ode78d (@var{fun}, @var{trange}, @var{init}, @var{lags}, @var{history}, @var{ode_opt})
@deftypefnx {} {[@var{t}, @var{y}, @var{te}, @var{ye}, @var{ie}] =} ode78d (@dots{})
@deftypefnx {} {@var{solution} =} ode78d (@dots{})

Solve a set of non--stiff delay differential equations (non--stiff DDEs) with
a modified version of the well known explicit Runge--Kutta method of order
(7,8).

@var{fun} is a function handle, inline function, or string containing the
name of the function that defines the ODE: @code{y' = f(t,y)}.  The function
must accept two inputs where the first is time @var{t} and the second is a
column vector of unknowns @var{y}.

@var{trange} specifies the time interval over which the ODE will be
evaluated.  Typically, it is a two-element vector specifying the initial and
final times (@code{[tinit, tfinal]}).  If there are more than two elements
then the solution will also be evaluated at these intermediate time
instances using a Hermite interpolation of order 3.

@var{init} contains the initial value for the unknowns.  If it is a row
vector then the solution @var{y} will be a matrix in which each column is
the solution for the corresponding initial value in @var{init}.

@var{lags} is a vector that describes the lags of time.

@var{history} is a matrix and describes the history of the DDEs.

The optional fourth argument @var{ode_opt} specifies non-default options to
the ODE solver. It is a structure generated by @code{odeset}. @code{ode78d}
will ignore the following options: "BDF", "InitialSlope", "Jacobian",
"JPattern", "MassSingular", "MaxOrder", "MvPattern", "Vectorized".

The function typically returns two outputs.  Variable @var{t} is a
column vector and contains the times where the solution was computed.  The
output @var{y} is a matrix in which each column refers to a different
unknown of the problem and each row corresponds to a time in @var{t}.  If
@var{trange} specifies intermediate time steps, only those will be returned.

The output can also be returned as a structure @var{solution} which
has field @var{x} containing the time where the solution was evaluated and
field @var{y} containing the solution matrix for the times in @var{x}.
Use @code{fieldnames (@var{solution})} to see the other fields and
additional information returned.

If using the @code{"Events"} option then three additional outputs may
be returned.  @var{te} holds the time when an Event function returned a
zero.  @var{ye} holds the value of the solution at time @var{te}.  @var{ie}
contains an index indicating which Event function was triggered in the case
of multiple Event functions.

In other words, this function will solve a problem of the form
@example
dy/dt = fun (t, y(t), y(t-lags(1), y(t-lags(2), @dots{})))
y(slot(1)) = init
y(slot(1)-lags(1)) = hist(1), y(slot(1)-lags(2)) = hist(2), @dots{}
@end example

For example:
@itemize @minus
@item
the following code solves an anonymous implementation of a chaotic behavior

@example
fcao = @@(vt, vy, vz) [2 * vz / (1 + vz^9.65) - vy];

vopt = odeset ("NormControl", "on", "RelTol", 1e-3);
vsol = ode78d (fcao, [0, 100], 0.5, 2, 0.5, vopt);

vlag = interp1 (vsol.x, vsol.y, vsol.x - 2);
plot (vsol.y, vlag); legend ("fcao (t,y,z)");
@end example

@item
to solve the following problem with two delayed state variables

@example
d y1(t)/dt = -y1(t)
d y2(t)/dt = -y2(t) + y1(t-5)
d y3(t)/dt = -y3(t) + y2(t-10)*y1(t-10)
@end example

one might do the following

@example
function f = fun (t, y, yd)
f(1) = -y(1);                   %% y1' = -y1(t)
f(2) = -y(2) + yd(1,1);         %% y2' = -y2(t) + y1(t-lags(1))
f(3) = -y(3) + yd(2,2)*yd(1,2); %% y3' = -y3(t) + y2(t-lags(2))*y1(t-lags(2))
end
T = [0,20]
res = ode78d (@@fun, T, [1;1;1], [5, 10], ones (3,2));
@end example

@end itemize
@c @seealso{odeset, ode23d, ode45d}
@end deftypefn

@deftypefn  {Function File} {[@var{t}, @var{y}] =} odeRATTLE (@var{fun}, @var{constr}, @var{trange}, @var{init})
@deftypefnx {Function File} {[@var{t}, @var{y}] =} odeRATTLE (@var{fun}, @var{constr}, @var{trange}, @var{init}, @var{ode_opt})
@deftypefnx {Function File} {[@var{t}, @var{y}] =} odeRATTLE (@dots{}, @var{par1}, @var{par2}, @dots{})
@deftypefnx {Function File} {[@var{t}, @var{y}, @var{te}, @var{ye}, @var{ie}] =} odeRATTLE (@dots{})
@deftypefnx {Function File} {@var{solution} =} odeRATTLE (@dots{})

This function is a geometric integrator for constrained Hamilton's equations
of motion that uses the RATTLE method of order 2 to find the new solution,
step by step.

@var{fun} is a function_handle or an inline function that
defines the system
@ifhtml
@example
@math{q' =  dH/dp (t,[q;p])}
@math{p' = -dH/dq (t,[q;p])}
@end example
@end ifhtml
@ifnothtml
@math{q' =  dH/dp (t,[q;p])}
@math{p' = -dH/dq (t,[q;p])},
@end ifnothtml
where @math{H(t,[q;p])} is the Hamiltonian of the problem, @math{q} are
generalized coordinates and @math{p} are generalized momenta. This function
must take two input arguments: the time and the unknowns. It must return a
vector or a cell (if the Hamiltonian Hessian is passed to speedup
computations) containing as first element the Hamilton's equations of motion
(the previous system of equations) and as second element the Hessian of the
Hamiltonian.

@var{constr} is a function_handle or an inline function
that defines the constraints of the problem @math{g(q)=0}. This
function must take one input argument and must return a vector or a cell (if
the constraint gradient and constraint Hessian are passed) containing as
first element the equations defining the holonomic constraints and as second
and third elements respectively the gradient and the Hessian of this
constraints function (this is not mandatory but it can speedup the
computation and improve accuracy).

@var{trange} specifies the time interval over which the ODE will be
evaluated.  Typically, it is a two-element vector specifying the initial and
final times (@code{[tinit, tfinal]}).  If there are more than two elements
then the solution will also be evaluated at these intermediate time
instances using linear interpolation.

By default, @code{odeRATTLE} uses an adaptive timestep with the
@code{integrate_adaptive} algorithm.  The tolerance for the timestep
computation may be changed by using the options @code{"RelTol"}
and @code{"AbsTol"}.

@var{init} contains the initial value for the unknowns.  It is a row or
column vector containing the generalized coordinates in its first half and
the generalized momenta in the second half.  Each momentum correspond to the
coordinate with the same relative position inside the vector of initial
conditions.

The optional fourth argument @var{ode_opt} specifies non-default options to
the ODE solver. It is a structure generated by @code{odeset}.  @code{ode12}
will ignore the following options: "BDF", "InitialSlope", "Jacobian",
"JPattern", "MassSingular", "MaxOrder", "MvPattern", "Vectorized".  The user
can set extra options by adding fields to the structure.  @code{odeRATTLE}
allows for:

@table @asis
@item  NewtonTol
the tolerance for the Newton algorithm [Default = 1e-7].

@item  MaxNewtonIterations
maximum number of Newton iterations [Default = 100].

@item  InexactSolver
the Newton solver. It can be set to either ["newton_raphson"],
"inexact_newton" or "fsolve".

@item  ConstraintFcn
function_handle representing the constraints of the system.

@item  ConstraintGradFcn
function_handle representing the gradient of the constraints of the system.

@item  ConstraintHessFcn
function_handle representing the Hessian of the Hamiltonian of the system,

@item  ConstraintsNb
positive integer equal to the number of constraints of the system.

@item  HamiltonianHessFcn
function_handle representing the Hessian of the Hamiltonian of the system.
@end table

If the "inexact_newton" solver is set, a further set of options can be
provided:

@table @asis
@item  UseJacobian
It can be set to either "yes" or ["no].  In the first case, the Hamiltonian
Hessian, the constraint gradient and the constraint Hessian will be used.
If they are not provided, they will be approximated by the utility
functions @command{approx_Hamilt_Hess}, @command{approx_Constr_grad}
and @command{approx_Constr_Hess}.

@item  Eta
initial forcing term (must be in the interval [0,1)).  The dafault value is
set to 0.5.  For details see [1].

@item  Choice
select the forcing term. It can be 1 (Default) or 2.  For details see [1].

@item  Algorithm
iterative method to solve the linearized system.  It can be ["gmres"], "pcg"
or "bicgstab".

@item  Restart
restart parameter for the GMRES solver (ignored for other solvers).
[Default = 20].
@end table

The function typically returns two outputs.  Variable @var{t} is a
column vector and contains the times where the solution was found.  The
output @var{y} is a matrix in which each column refers to a different
unknown of the problem and each row corresponds to a time in @var{t}.

The output can also be returned as a structure @var{solution} which
has field @var{x} containing the time where the solution was evaluated and
field @var{y} containing the solution matrix for the times in @var{x}.
Use @code{fieldnames (@var{solution})} to see the other fields and additional
information returned.

If using the @code{"Events"} option then three additional outputs may
be returned.  @var{te} holds the time when an Event function returned a
zero.  @var{ye} holds the value of the solution at time @var{te}.  @var{ie}
contains an index indicating which Event function was triggered in the case
of multiple Event functions.

References:

[1] S.C. Eisenstat and H.F. Walker, "Choosing the Forcing Terms in an Inexact
Newton Method." SIAM Journal on Scientific Computing, 17(1), pp. 16-16, 1996.
@c @seealso{odeset, odeSE, odeSPVI, odeSV, odeVV}
@end deftypefn

@deftypefn  {Function File} {[@var{t}, @var{y}] =} odeSE (@var{fun}, @var{trange}, @var{init})
@deftypefnx {Function File} {[@var{t}, @var{y}] =} odeSE (@var{fun}, @var{trange}, @var{init}, @var{ode_opt})
@deftypefnx {Function File} {[@var{t}, @var{y}] =} odeSE (@dots{}, @var{par1}, @var{par2}, @dots{})
@deftypefnx {Function File} {[@var{t}, @var{y}, @var{te}, @var{ye}, @var{ie}] =} odeSE (@dots{})
@deftypefnx {Function File} {@var{solution} =} odeSE (@dots{})

This function is a geometric integrator for Hamilton's equations of motion
that uses the Symplectic-Euler method of order 1 (also known as Semi-implicit
Euler method) to find the new solution, step by step.

@var{fun} is a function_handle or an inline function that
defines the system
@ifhtml
@example
@math{q' =  dH/dp (t,[q;p])}
@math{p' = -dH/dq (t,[q;p])}
@end example
@end ifhtml
@ifnothtml
@math{q' =  dH/dp (t,[q;p])}
@math{p' = -dH/dq (t,[q;p])},
@end ifnothtml
where @math{H(t,[q;p])} is the Hamiltonian of the problem, @math{q} are
generalized coordinates and @math{p} are generalized momenta.  This function
must take two input arguments: the time and the unknowns.  It must return a
vector or a cell (if the Hamiltonian Hessian is passed to speedup
computations) containing as first element the Hamilton's equations of motion
(the previous system of equations) and as second element the Hessian of the
Hamiltonian.

@var{trange} specifies the time interval over which the ODE will be
evaluated.  Typically, it is a two-element vector specifying the initial and
final times (@code{[tinit, tfinal]}).  If there are more than two elements
then the solution will also be evaluated at these intermediate time
instances using linear interpolation.

By default, @code{odeSE} uses an adaptive timestep with the
@code{integrate_adaptive} algorithm.  The tolerance for the timestep
computation may be changed by using the options @code{"RelTol"}
and @code{"AbsTol"}.

@var{init} contains the initial value for the unknowns.  It is a row or
column vector containing the generalized coordinates in its first half and
the generalized momenta in the second half.  Each momentum correspond to the
coordinate with the same relative position inside the vector of initial
conditions.

The optional fourth argument @var{ode_opt} specifies non-default options to
the ODE solver. It is a structure generated by @code{odeset}.  @code{ode12}
will ignore the following options: "BDF", "InitialSlope", "Jacobian",
"JPattern", "MassSingular", "MaxOrder", "MvPattern", "Vectorized".  The user
can set extra options by adding fields to the structure.  @code{odeSE}
allows for:

@table @asis
@item  NewtonTol
the tolerance for the Newton algorithm [Default = 1e-7].

@item  MaxNewtonIterations
maximum number of Newton iterations [Default = 100].

@item  InexactSolver
the Newton solver. It can be set to either ["newton_raphson"],
"inexact_newton" or "fsolve".

@item  Explicit
It can be set to either "yes" or ["no].  If the system is explicit, the
computation will be faster
@end table

If the "inexact_newton" solver is set, a further set of options can be
provided:

@table @asis
@item  UseJacobian
It can be set to either "yes" or ["no].  In the first case, the Hamiltonian
Hessian, the constraint gradient and the constraint Hessian will be used.
If they are not provided, they will be approximated by the utility
functions @command{approx_Hamilt_Hess}, @command{approx_Constr_grad}
and @command{approx_Constr_Hess}.

@item  Eta
initial forcing term (must be in the interval [0,1)).  The dafault value is
set to 0.5.  For details see [1].

@item  Choice
select the forcing term. It can be 1 (Default) or 2.  For details see [1].

@item  Algorithm
iterative method to solve the linearized system.  It can be ["gmres"], "pcg"
or "bicgstab".

@item  Restart
restart parameter for the GMRES solver (ignored for other solvers).
[Default = 20].
@end table

The function typically returns two outputs.  Variable @var{t} is a
column vector and contains the times where the solution was found.  The
output @var{y} is a matrix in which each column refers to a different
unknown of the problem and each row corresponds to a time in @var{t}.

The output can also be returned as a structure @var{solution} which
has field @var{x} containing the time where the solution was evaluated and
field @var{y} containing the solution matrix for the times in @var{x}.
Use @code{fieldnames (@var{solution})} to see the other fields and additional
information returned.

If using the @code{"Events"} option then three additional outputs may
be returned.  @var{te} holds the time when an Event function returned a
zero.  @var{ye} holds the value of the solution at time @var{te}.  @var{ie}
contains an index indicating which Event function was triggered in the case
of multiple Event functions.

References:

[1] S.C. Eisenstat and H.F. Walker, "Choosing the Forcing Terms in an Inexact
Newton Method." SIAM Journal on Scientific Computing, 17(1), pp. 16-16, 1996.
@c @seealso{odeset, odefwe, inexact_newton}
@end deftypefn

@deftypefn  {Function File} {[@var{t}, @var{y}] =} odeSV (@var{fun}, @var{trange}, @var{init})
@deftypefnx {Function File} {[@var{t}, @var{y}] =} odeSV (@var{fun}, @var{trange}, @var{init}, @var{ode_opt})
@deftypefnx {Function File} {[@var{t}, @var{y}] =} odeSV (@dots{}, @var{par1}, @var{par2}, @dots{})
@deftypefnx {Function File} {[@var{t}, @var{y}, @var{te}, @var{ye}, @var{ie}] =} odeSV (@dots{})
@deftypefnx {Function File} {@var{solution} =} odeSV (@dots{})

This function is a geometric integrator for Hamilton's equations of motion
that uses the Stormer-Verlet method of order 2.

@var{fun} is a function_handle or an inline function that
defines the system
@ifhtml
@example
@math{q' =  dH/dp (t,[q;p])}
@math{p' = -dH/dq (t,[q;p])}
@end example
@end ifhtml
@ifnothtml
@math{q' =  dH/dp (t,[q;p])}
@math{p' = -dH/dq (t,[q;p])},
@end ifnothtml
where @math{H(t,[q;p])} is the Hamiltonian of the problem, @math{q} are
generalized coordinates and @math{p} are generalized momenta. This function
must take two input arguments: the time and the unknowns. It must return a
vector or a cell (if the Hamiltonian Hessian is passed to speedup
computations) containing as first element the Hamilton's equations of motion
(the previous system of equations) and as second element the Hessian of the
Hamiltonian.

@var{trange} specifies the time interval over which the ODE will be
evaluated.  Typically, it is a two-element vector specifying the initial and
final times (@code{[tinit, tfinal]}).  If there are more than two elements
then the solution will also be evaluated at these intermediate time
instances using quadratic interpolation.

By default, @code{odeSE} uses an adaptive timestep with the
@code{integrate_adaptive} algorithm.  The tolerance for the timestep
computation may be changed by using the options @code{"RelTol"}
and @code{"AbsTol"}.

@var{init} contains the initial value for the unknowns.  It is a row or
column vector containing the generalized coordinates in its first half and
the generalized momenta in the second half.  Each momentum correspond to the
coordinate with the same relative position inside the vector of initial
conditions.

The optional fourth argument @var{ode_opt} specifies non-default options to
the ODE solver. It is a structure generated by @code{odeset}.  @code{ode12}
will ignore the following options: "BDF", "InitialSlope", "Jacobian",
"JPattern", "MassSingular", "MaxOrder", "MvPattern", "Vectorized".  The user
can set extra options by adding fields to the structure.  @code{odeSV}
allows for:

@table @asis
@item  NewtonTol
the tolerance for the Newton algorithm [Default = 1e-7].

@item  MaxNewtonIterations
maximum number of Newton iterations [Default = 100].

@item  InexactSolver
the Newton solver. It can be set to either ["newton_raphson"],
"inexact_newton" or "fsolve".

@item  Explicit
It can be set to either "yes" or ["no].  If the system is explicit, the
computation will be faster
@end table

If the "inexact_newton" solver is set, a further set of options can be
provided:

@table @asis
@item  UseJacobian
It can be set to either "yes" or ["no].  In the first case, the Hamiltonian
Hessian, the constraint gradient and the constraint Hessian will be used.
If they are not provided, they will be approximated by the utility
functions @command{approx_Hamilt_Hess}, @command{approx_Constr_grad}
and @command{approx_Constr_Hess}.

@item  Eta
initial forcing term (must be in the interval [0,1)).  The dafault value is
set to 0.5.  For details see [1].

@item  Choice
select the forcing term. It can be 1 (Default) or 2.  For details see [1].

@item  Algorithm
iterative method to solve the linearized system.  It can be ["gmres"], "pcg"
or "bicgstab".

@item  Restart
restart parameter for the GMRES solver (ignored for other solvers).
[Default = 20].
@end table

The function typically returns two outputs.  Variable @var{t} is a
column vector and contains the times where the solution was found.  The
output @var{y} is a matrix in which each column refers to a different
unknown of the problem and each row corresponds to a time in @var{t}.

The output can also be returned as a structure @var{solution} which
has field @var{x} containing the time where the solution was evaluated and
field @var{y} containing the solution matrix for the times in @var{x}.
Use @code{fieldnames (@var{solution})} to see the other fields and additional
information returned.

If using the @code{"Events"} option then three additional outputs may
be returned.  @var{te} holds the time when an Event function returned a
zero.  @var{ye} holds the value of the solution at time @var{te}.  @var{ie}
contains an index indicating which Event function was triggered in the case
of multiple Event functions.

References:

[1] S.C. Eisenstat and H.F. Walker, "Choosing the Forcing Terms in an Inexact
Newton Method." SIAM Journal on Scientific Computing, 17(1), pp. 16-16, 1996.
@c @seealso{odeset, odeRATTLE, odeSE, odeSPVI, odeVV}
@end deftypefn

@deftypefn {Command} {[@var{sol}] =} odeVV (@var{@@fun}, @var{trange}, @var{init}, [@var{opt}], [@var{par1}, @var{par2}, @dots{}])
@deftypefnx {Command} {[@var{t}, @var{y}, [@var{xe}, @var{ye}, @var{ie}]] =} odeVV (@var{@@fun}, @var{trange}, @var{init}, [@var{opt}], [@var{par1}, @var{par2}, @dots{}])

This function is a geometric integrator for Newton's equations of motion that
uses the Velocity-Verlet method of order 2.

@var{fun} is a function_handle or an inline function that
defines the system
@ifhtml
@example
@math{q' =  dH/dp (t,[q;p])}
@math{p' = -dH/dq (t,[q;p])}
@end example
@end ifhtml
@ifnothtml
@math{q' =  dH/dp (t,[q;p])}
@math{p' = -dH/dq (t,[q;p])},
@end ifnothtml
where @math{H(t,[q;p])} is the Hamiltonian of the problem, @math{q} are
generalized coordinates and @math{p} are generalized momenta. This function
must take two input arguments: the time and the unknowns. It must return a
vector or a cell (if the Hamiltonian Hessian is passed to speedup
computations) containing as first element the Hamilton's equations of motion
(the previous system of equations) and as second element the Hessian of the
Hamiltonian.

@var{trange} specifies the time interval over which the ODE will be
evaluated.  Typically, it is a two-element vector specifying the initial and
final times (@code{[tinit, tfinal]}).  If there are more than two elements
then the solution will also be evaluated at these intermediate time
instances using quadratic interpolation.

By default, @code{odeVV} uses an adaptive timestep with the
@code{integrate_adaptive} algorithm.  The tolerance for the timestep
computation may be changed by using the options @code{"RelTol"}
and @code{"AbsTol"}.

@var{init} contains the initial value for the unknowns.  It is a row or
column vector containing the generalized coordinates in its first half and
the generalized momenta in the second half.  Each momentum correspond to the
coordinate with the same relative position inside the vector of initial
conditions.

The optional fourth argument @var{ode_opt} specifies non-default options to
the ODE solver. It is a structure generated by @code{odeset}.  @code{ode12}
will ignore the following options: "BDF", "InitialSlope", "Jacobian",
"JPattern", "MassSingular", "MaxOrder", "MvPattern", "Vectorized".  The user
can set extra options by adding fields to the structure.  @code{odeSV}
allows for:

@table @asis
@item  NewtonTol
the tolerance for the Newton algorithm [Default = 1e-7].

@item  MaxNewtonIterations
maximum number of Newton iterations [Default = 100].

@item  InexactSolver
the Newton solver. It can be set to either ["newton_raphson"],
"inexact_newton" or "fsolve".

@item  Explicit
It can be set to either "yes" or ["no].  If the system is explicit, the
computation will be faster
@end table

If the "inexact_newton" solver is set, a further set of options can be
provided:

@table @asis
@item  UseJacobian
It can be set to either "yes" or ["no].  In the first case, the Hamiltonian
Hessian, the constraint gradient and the constraint Hessian will be used.
If they are not provided, they will be approximated by the utility
functions @command{approx_Hamilt_Hess}, @command{approx_Constr_grad}
and @command{approx_Constr_Hess}.

@item  Eta
initial forcing term (must be in the interval [0,1)).  The dafault value is
set to 0.5.  For details see [1].

@item  Choice
select the forcing term. It can be 1 (Default) or 2.  For details see [1].

@item  Algorithm
iterative method to solve the linearized system.  It can be ["gmres"], "pcg"
or "bicgstab".

@item  Restart
restart parameter for the GMRES solver (ignored for other solvers).
[Default = 20].
@end table

The function typically returns two outputs.  Variable @var{t} is a
column vector and contains the times where the solution was found.  The
output @var{y} is a matrix in which each column refers to a different
unknown of the problem and each row corresponds to a time in @var{t}.

The output can also be returned as a structure @var{solution} which
has field @var{x} containing the time where the solution was evaluated and
field @var{y} containing the solution matrix for the times in @var{x}.
Use @code{fieldnames (@var{solution})} to see the other fields and additional
information returned.

If using the @code{"Events"} option then three additional outputs may
be returned.  @var{te} holds the time when an Event function returned a
zero.  @var{ye} holds the value of the solution at time @var{te}.  @var{ie}
contains an index indicating which Event function was triggered in the case
of multiple Event functions.

References:

[1] S.C. Eisenstat and H.F. Walker, "Choosing the Forcing Terms in an Inexact
Newton Method." SIAM Journal on Scientific Computing, 17(1), pp. 16-16, 1996.
@c @seealso{odeset, odeRATTLE, odeSE, odeSPVI, odeSV}
@end deftypefn

@deftypefn  {Function File} {[@var{t}, @var{y}] =} odebwe (@var{fun}, @var{trange}, @var{init})
@deftypefnx {Function File} {[@var{t}, @var{y}] =} odebwe (@var{fun}, @var{trange}, @var{init}, @var{ode_opt})
@deftypefnx {Function File} {[@var{t}, @var{y}] =} odebwe (@dots{}, @var{par1}, @var{par2}, @dots{})
@deftypefnx {Function File} {[@var{t}, @var{y}, @var{te}, @var{ye}, @var{ie}] =} odebwe (@dots{})
@deftypefnx {Function File} {@var{solution} =} odebwe (@dots{})

Solve a set of Ordinary Differential Equations with the well known implicit
Backward-Euler method of order 1. The method is indicated both for stiff and
non--stiff problems.

@var{fun} is a function handle, inline function, or string containing the
name of the function that defines the ODE: @code{y' = f(t,y)}.  The function
must accept two inputs where the first is time @var{t} and the second is a
column vector of unknowns @var{y}.

@var{trange} specifies the time interval over which the ODE will be
evaluated.  Typically, it is a two-element vector specifying the initial and
final times (@code{[tinit, tfinal]}).  If there are more than two elements
then the solution will also be evaluated at these intermediate time
instances using linear interpolation.

@var{init} contains the initial value for the unknowns.  If it is a row
vector then the solution @var{y} will be a matrix in which each column is
the solution for the corresponding initial value in @var{init}.

The optional fourth argument @var{ode_opt} specifies non-default options to
the ODE solver.  It is a structure generated by @code{odeset}.  @code{odebwe}
will ignore the following options: "BDF", "InitialSlope", "MassSingular",
"MaxOrder", "MvPattern", "NonNegative".  The user can set extra options by
adding fields to the structure.  @code{odebwe} allows for:

@table @asis
@item  NewtonTol
the tolerance for the Newton algorithm [Default = 1e-7].

@item  MaxNewtonIterations
maximum number of Newton iterations [Default = 100].

@item  InexactSolver
the Newton solver. It can be set to either ["newton_raphson"],
"inexact_newton" or "fsolve".
@end table

If the "inexact_newton" solver is set, a further set of options can be
provided:

@table @asis
@item  UseJacobian
specify if the Jacobian information should be used. It can be set to either
"yes" or ["no].

@item  Eta
initial forcing term (must be in the interval [0,1)).  The dafault value is
set to 0.5.  For details see [1].

@item  Choice
select the forcing term. It can be 1 (Default) or 2.  For details see [1].

@item  Algorithm
iterative method to solve the linearized system.  It can be ["gmres"], "pcg"
or "bicgstab".

@item  Restart
restart parameter for the GMRES solver (ignored for other solvers).
[Default = 20].
@end table

The function typically returns two outputs.  Variable @var{t} is a
column vector and contains the times where the solution was found.  The
output @var{y} is a matrix in which each column refers to a different
unknown of the problem and each row corresponds to a time in @var{t}.

The output can also be returned as a structure @var{solution} which
has field @var{x} containing the time where the solution was evaluated and
field @var{y} containing the solution matrix for the times in @var{x}.
Use @code{fieldnames (@var{solution})} to see the other fields and additional
information returned.

If using the @code{"Events"} option then three additional outputs may
be returned.  @var{te} holds the time when an Event function returned a
zero.  @var{ye} holds the value of the solution at time @var{te}.  @var{ie}
contains an index indicating which Event function was triggered in the case
of multiple Event functions.

For example, solve an anonymous implementation of the Van der Pol equation

@example
@group
fvdp = @@(@var{t},@var{y}) [@var{y}(2); (1 - @var{y}(1)^2) * @var{y}(2) - @var{y}(1)];
[@var{t},@var{y}] = odebwe (fvdp, [0, 2], [2, 0]);
@end group
@end example

References:

[1] S.C. Eisenstat and H.F. Walker, "Choosing the Forcing Terms in an Inexact
Newton Method." SIAM Journal on Scientific Computing, 17(1), pp. 16-16, 1996.
@c @seealso{odeset, odefwe, inexact_newton}
@end deftypefn

@deftypefn {Function File} {[@var{}] =} odeexamples (@var{})

Open the differential equations examples menu and allow the user to select a
submenu of ODE, DAE, IDE or DDE examples.
@end deftypefn

@deftypefn  {Function File} {[@var{t}, @var{y}] =} odefwe (@var{fun}, @var{trange}, @var{init})
@deftypefnx {Function File} {[@var{t}, @var{y}] =} odefwe (@var{fun}, @var{trange}, @var{init}, @var{ode_opt})
@deftypefnx {Function File} {[@var{t}, @var{y}] =} odefwe (@dots{}, @var{par1}, @var{par2}, @dots{})
@deftypefnx {Function File} {[@var{t}, @var{y}, @var{te}, @var{ye}, @var{ie}] =} odefwe (@dots{})
@deftypefnx {Function File} {@var{solution} =} odefwe (@dots{})

Solve a set of non-stiff Ordinary Differential Equations (non-stiff ODEs)
with the well known explicit Forward-Euler method of order 1.

@var{fun} is a function handle, inline function, or string containing the
name of the function that defines the ODE: @code{y' = f(t,y)}.  The function
must accept two inputs where the first is time @var{t} and the second is a
column vector of unknowns @var{y}.

@var{trange} specifies the time interval over which the ODE will be
evaluated.  Typically, it is a two-element vector specifying the initial and
final times (@code{[tinit, tfinal]}).  If there are more than two elements
then the solution will also be evaluated at these intermediate time
instances using an interpolation procedure of the same order as the one of
the solver.

By default, @code{odefwe} uses an adaptive timestep with the
@code{integrate_adaptive} algorithm.  The tolerance for the timestep
computation may be changed by using the options @code{"RelTol"}
and @code{"AbsTol"}.

@var{init} contains the initial value for the unknowns.  If it is a row
vector then the solution @var{y} will be a matrix in which each column is
the solution for the corresponding initial value in @var{init}.

The optional fourth argument @var{ode_opt} specifies non-default options to
the ODE solver. It is a structure generated by @code{odeset}.  @code{odefwe}
will ignore the following options: "BDF", "InitialSlope", "Jacobian",
"JPattern", "MassSingular", "MaxOrder", "MvPattern", "Vectorized".

The function typically returns two outputs.  Variable @var{t} is a
column vector and contains the times where the solution was computed.  The
output @var{y} is a matrix in which each column refers to a different
unknown of the problem and each row corresponds to a time in @var{t}.  If
@var{trange} specifies intermediate time steps, only those will be returned.

The output can also be returned as a structure @var{solution} which
has a field @var{x} containing a row vector of times where the solution
was evaluated and a field @var{y} containing the solution matrix such
that each column corresponds to a time in @var{x}.
Use @code{fieldnames (@var{solution})} to see the other fields and
additional information returned.

If using the @code{"Events"} option then three additional outputs may
be returned.  @var{te} holds the time when an Event function returned a
zero.  @var{ye} holds the value of the solution at time @var{te}.  @var{ie}
contains an index indicating which Event function was triggered in the case
of multiple Event functions.

Example: Solve the Van der Pol equation

@example
@group
fvdp = @@(@var{t},@var{y}) [@var{y}(2); (1 - @var{y}(1)^2) * @var{y}(2) - @var{y}(1)];
[@var{t},@var{y}] = odefwe (fvdp, [0 20], [2 0]);
@end group
@end example
@c @seealso{odeset, odebwe}
@end deftypefn

@deftypefn {Function File} {[@var{ret}] =} odephas2 (@var{t}, @var{y}, @var{flag})

Open a new figure window and plot the first result from the variable @var{y}
that is of type double column vector over the second result from the variable
@var{y} while solving.  The types and the values of the input parameter
@var{t} and the output parameter @var{ret} depend on the input value
@var{flag} that is of type string. If @var{flag} is

@table @option
@item  @code{"init"}
then @var{t} must be a double column vector of length 2 with the first and
the last time step and nothing is returned from this function.

@item  @code{""}
then @var{t} must be a double scalar specifying the actual time step and the
return value is false (resp. value 0) for 'not stop solving'.

@item  @code{"done"}
then @var{t} must be a double scalar specifying the last time step and
nothing is returned from this function.
@end table

This function is called by a OdePkg solver function if it was specified in an
OdePkg options structure with the @command{odeset}.  This function is an
OdePkg internal helper function therefore it should never be necessary that
this function is called directly by a user.  There is only little error
detection implemented in this function file to achieve the highest
performance.

Example: Solve the Van der Pol equation and display the results
while solving in a 2D plane
@example
fvdb = @@(vt,vy) [vy(2); (1 - vy(1)^2) * vy(2) - vy(1)];

vopt = odeset ('OutputFcn', @@odephas2, 'RelTol', 1e-6);
vsol = ode45 (fvdb, [0 20], [2 0], vopt);
@end example
@c @seealso{odeset, odeplot, odephas3}
@end deftypefn

@deftypefn {Function File} {[@var{ret}] =} odephas3 (@var{t}, @var{y}, @var{flag})

Open a new figure window and plot the first result from the variable @var{y}
that is of type double column vector over the second and the third result
from the variable @var{y} while solving. The types and the values of the
input parameter @var{t} and the output parameter @var{ret} depend on the
input value @var{flag} that is of type string. If @var{flag} is

@table @option
@item  @code{"init"}
then @var{t} must be a double column vector of length 2 with the first and
the last time step and nothing is returned from this function.

@item  @code{""}
then @var{t} must be a double scalar specifying the actual time step and the
return value is false (resp. value 0) for 'not stop solving'.

@item  @code{"done"}
then @var{t} must be a double scalar specifying the last time step and
nothing is returned from this function.
@end table

This function is called by a OdePkg solver function if it was specified in an
OdePkg options structure with the @command{odeset}.  This function is an
OdePkg internal helper function therefore it should never be necessary that
this function is called directly by a user.  There is only little error
detection implemented in this function file to achieve the highest
performance.

Example: Solve the Van der Pol equation and display the results
while solving in a 3D plane
@example
function vyd = florenz (vt, vx)
  vyd = [10 * (vx(2) - vx(1));
         vx(1) * (28 - vx(3));
         vx(1) * vx(2) - 8/3 * vx(3)];
end

vopt = odeset ('OutputFcn', @@odephas3); 
vsol = ode23 (@@florenz, [0:0.01:7.5], [3 15 1], vopt);
@end example
@c @seealso{odeset, odeplot, odephas2}
@end deftypefn

@deftypefn {Function File} {[@var{}] =} odepkg ()

OdePkg is part of the GNU Octave Repository (the Octave--Forge project). The package includes commands for setting up various options, output functions etc. before solving a set of differential equations with the solver functions that are also included. At this time OdePkg is under development with the main target to make a package that is mostly compatible to proprietary solver products.

If this function is called without any input argument then open the OdePkg tutorial in the Octave window. The tutorial can also be opened with the following command

@example
doc odepkg
@end example
@end deftypefn

@deftypefn {Function File} {[@var{}] =} odepkg_examples_dae (@var{})
Open the DAE examples menu and allow the user to select a demo that will be evaluated.
@end deftypefn

@deftypefn {Function File} {[@var{}] =} odepkg_examples_dde (@var{})
Open the DDE examples menu and allow the user to select a demo that will be evaluated.
@end deftypefn

@deftypefn {Function File} {[@var{}] =} odepkg_examples_ide (@var{})
Open the IDE examples menu and allow the user to select a demo that will be evaluated.
@end deftypefn

@deftypefn {Function File} {[@var{}] =} odepkg_examples_ode (@var{})
Open the ODE examples menu and allow the user to select a demo that will be evaluated.
@end deftypefn

@deftypefn {Function File} {[@var{mescd}] =} odepkg_testsuite_calcmescd (@var{solution}, @var{reference}, @var{abstol}, @var{reltol})

If this function is called with four input arguments of type double scalar or
column vector then return a normalized value for the minimum number of
correct digits @var{mescd} that is calculated from the solution at the end of
an integration interval @var{solution} and a set of reference values
@var{reference}. The input arguments @var{abstol} and @var{reltol} are used
to calculate a reference solution that depends on the relative and absolute
error tolerances.

Run examples with the command
@example
demo odepkg_testsuite_calcmescd
@end example

This function has been ported from the "Test Set for IVP solvers" which is
developed by the INdAM Bari unit project group "Codes and Test Problems for
Differential Equations", coordinator F. Mazzia.
@end deftypefn

@deftypefn {Function File} {[@var{scd}] =} odepkg_testsuite_calcscd (@var{solution}, @var{reference}, @var{abstol}, @var{reltol})

If this function is called with four input arguments of type double scalar or
column vector then return a normalized value for the minimum number of
correct digits @var{scd} that is calculated from the solution at the end of
an integration interval @var{solution} and a set of reference values
@var{reference}. The input arguments @var{abstol} and @var{reltol} are unused
but present because of compatibility to the function
@command{odepkg_testsuite_calcmescd}.

Run examples with the command
@example
demo odepkg_testsuite_calcscd
@end example

This function has been ported from the "Test Set for IVP solvers" which is
developed by the INdAM Bari unit project group "Codes and Test Problems for
Differential Equations", coordinator F. Mazzia.
@end deftypefn

@deftypefn {Function File} {[@var{solution}] =} odepkg_testsuite_chemakzo (@var{@@solver}, @var{reltol})

If this function is called with two input arguments and the first input
argument @var{@@solver} is a function handle describing an OdePkg solver and
the second input argument @var{reltol} is a double scalar describing the
relative error tolerance then return a cell array @var{solution} with
performance informations about the chemical AKZO Nobel testsuite of
differential algebraic equations after solving (DAE--test).

Run examples with the command
@example
demo odepkg_testsuite_chemakzo
@end example

This function has been ported from the "Test Set for IVP solvers" which is
developed by the INdAM Bari unit project group "Codes and Test Problems for
Differential Equations", coordinator F. Mazzia.
@end deftypefn

@deftypefn {Function File} {[@var{solution}] =} odepkg_testsuite_hires (@var{@@solver}, @var{reltol})

If this function is called with two input arguments and the first input
argument @var{@@solver} is a function handle describing an OdePkg solver and
the second input argument @var{reltol} is a double scalar describing the
relative error tolerance then return a cell array @var{solution} with
performance informations about the HIRES testsuite of ordinary differential
equations after solving (ODE--test).

Run examples with the command
@example
demo odepkg_testsuite_hires
@end example

This function has been ported from the "Test Set for IVP solvers" which is
developed by the INdAM Bari unit project group "Codes and Test Problems for
Differential Equations", coordinator F. Mazzia.
@end deftypefn

@deftypefn {Function File} {[@var{solution}] =} odepkg_testsuite_implakzo (@var{@@solver}, @var{reltol})

If this function is called with two input arguments and the first input
argument @var{@@solver} is a function handle describing an OdePkg solver and
the second input argument @var{reltol} is a double scalar describing the
relative error tolerance then return a cell array @var{solution} with
performance informations about the chemical AKZO Nobel testsuite of implicit
differential algebraic equations after solving (IDE--test).

Run examples with the command
@example
demo odepkg_testsuite_implakzo
@end example

This function has been ported from the "Test Set for IVP solvers" which is
developed by the INdAM Bari unit project group "Codes and Test Problems for
Differential Equations", coordinator F. Mazzia.
@end deftypefn

@deftypefn {Function File} {[@var{solution}] =} odepkg_testsuite_implrober (@var{@@solver}, @var{reltol})

If this function is called with two input arguments and the first input
argument @var{@@solver} is a function handle describing an OdePkg solver and
the second input argument @var{reltol} is a double scalar describing the
relative error tolerance then return a cell array @var{solution} with
performance informations about the implicit form of the modified ROBERTSON
testsuite of implicit differential algebraic equations after solving
(IDE--test).

Run examples with the command
@example
demo odepkg_testsuite_implrober
@end example

This function has been ported from the "Test Set for IVP solvers" which is
developed by the INdAM Bari unit project group "Codes and Test Problems for
Differential Equations", coordinator F. Mazzia.
@end deftypefn

@deftypefn {Function File} {[@var{solution}] =} odepkg_testsuite_oregonator (@var{@@solver}, @var{reltol})

If this function is called with two input arguments and the first input
argument @var{@@solver} is a function handle describing an OdePkg solver and
the second input argument @var{reltol} is a double scalar describing the
relative error tolerance then return a cell array @var{solution} with
performance informations about the OREGONATOR testsuite of ordinary
differential equations after solving (ODE--test).

Run examples with the command
@example
demo odepkg_testsuite_oregonator
@end example

This function has been ported from the "Test Set for IVP solvers" which is
developed by the INdAM Bari unit project group "Codes and Test Problems for
Differential Equations", coordinator F. Mazzia.
@end deftypefn

@deftypefn {Function File} {[@var{solution}] =} odepkg_testsuite_pollution (@var{@@solver}, @var{reltol})

If this function is called with two input arguments and the first input
argument @var{@@solver} is a function handle describing an OdePkg solver and
the second input argument @var{reltol} is a double scalar describing the
relative error tolerance then return the cell array @var{solution} with
performance informations about the POLLUTION testsuite of ordinary
differential equations after solving (ODE--test).

Run examples with the command
@example
demo odepkg_testsuite_pollution
@end example

This function has been ported from the "Test Set for IVP solvers" which is
developed by the INdAM Bari unit project group "Codes and Test Problems for
Differential Equations", coordinator F. Mazzia.
@end deftypefn

@deftypefn {Function File} {[@var{solution}] =} odepkg_testsuite_robertson (@var{@@solver}, @var{reltol})

If this function is called with two input arguments and the first input
argument @var{@@solver} is a function handle describing an OdePkg solver and
the second input argument @var{reltol} is a double scalar describing the
relative error tolerance then return a cell array @var{solution} with
performance informations about the modified ROBERTSON testsuite of
differential algebraic equations after solving (DAE--test).

Run examples with the command
@example
demo odepkg_testsuite_robertson
@end example

This function has been ported from the "Test Set for IVP solvers" which is
developed by the INdAM Bari unit project group "Codes and Test Problems for
Differential Equations", coordinator F. Mazzia.
@end deftypefn

@deftypefn {Function File} {[@var{solution}] =} odepkg_testsuite_transistor (@var{@@solver}, @var{reltol})

If this function is called with two input arguments and the first input
argument @var{@@solver} is a function handle describing an OdePkg solver and
the second input argument @var{reltol} is a double scalar describing the
relative error tolerance then return the cell array @var{solution} with
performance informations about the TRANSISTOR testsuite of differential
algebraic equations after solving (DAE--test).

Run examples with the command
@example
demo odepkg_testsuite_transistor
@end example

This function has been ported from the "Test Set for IVP solvers" which is
developed by the INdAM Bari unit project group "Codes and Test Problems for
Differential Equations", coordinator F. Mazzia.
@end deftypefn

@deftypefn {Function File} {[@var{ret}] =} odeprint (@var{t}, @var{y}, @var{flag})

Display the results of the set of differential equations in the Octave window
while solving.  The first column of the screen output shows the actual time
stamp that is given with the input arguemtn @var{t}, the following columns
show the results from the function evaluation that are given by the column
vector @var{y}.  The types and the values of the input parameter @var{t} and
the output parameter @var{ret} depend on the input value @var{flag} that is
of type string.  If @var{flag} is

@table @option
@item @code{"init"} then @var{t} must be a double column vector of length 2
with the first and thelast time step and nothing is returned from this
function,

@item @code{""}
then @var{t} must be a double scalar specifying the actual time step and the
return value is false (resp. value 0) for 'not stop solving',

@item @code{"done"} then @var{t} must be a double scalar specifying the
last time step and nothing is returned from this function.
@end table

This function is called by a OdePkg solver function if it was specified in an
OdePkg options structure with the @command{odeset}.  This function is an
OdePkg internal helper function therefore it should never be necessary that
this function is called directly by a user.  There is only little error
detection implemented in this function file to achieve the highest
performance.

Example: Solve the Van der Pol equation and print the results
while solving

@example
fvdb = @@(vt,vy) [vy(2); (1 - vy(1)^2) * vy(2) - vy(1)];
vopt = odeset ('OutputFcn', @@odeprint, 'RelTol', 1e-6);
vsol = ode45 (fvdb, [0 20], [2 0], vopt);
@end example
@end deftypefn

