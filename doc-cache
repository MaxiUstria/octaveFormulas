# doc-cache created by Octave 4.2.2
# name: cache
# type: cell
# rows: 3
# columns: 55
# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
approx_Constr_Hess


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 696
 -- Command: [J] = approx_Constr_Hess (@FUN, X)

     This function file can be used to approximate the Hessian of the
     constraints in a constrained Hamiltonian system solved with
     'odeRATTLE'.

     If no explicit expression for the Hessian is given to 'odeRATTLE',
     it calls this function to approximate it.

     The output argument is a three-dimensional matrix where the last
     dimension refers to each different constraint.

     The first input argument must be a function_handle or an inline
     function and must define the gradient of the constraints.

     The second input argument is just the point at which the Hessian
     will be evaluated.

     See also: odepkg.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
This function file can be used to approximate the Hessian of the
constraints in 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
approx_Constr_grad


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 666
 -- Command: [J] = approx_Constr_grad (@FUN, X)

     This function file can be used to approximate the gradient of the
     constraints in a constrained Hamiltonian system solved with
     'odeRATTLE'.

     If no explicit expression for the gradient is given to 'odeRATTLE',
     it calls this function to approximate it.

     The output argument is a matrix where the first dimension refers to
     each different constraint.

     The first input argument must be a function_handle or an inline
     function and must define the constraints.

     The second input argument is just the point at which the gradient
     will be evaluated.

     See also: odepkg.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
This function file can be used to approximate the gradient of the
constraints in



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
approx_Hamilt_Hess


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 724
 -- Command: [J] = approx_Hamilt_Hess (@FUN, T, X)

     This function file can be used to approximate the Hessian of the
     Hamiltonian in a generic Hamiltonian system solved with 'odeSE',
     'odeSV', 'odeSPVI', 'odeRATTLE'.

     If no explicit expression for the Hessian is given to the solver,
     it calls this function to approximate it.

     The output argument is a square matrix.

     The first input argument must be a function_handle or an inline
     function and must define the Hamilton's equations of motion: q' =
     dH/dp (t,[q;p]) p' = - dH/dq (t,[q;p]).

     The second and third input arguments are just the time and the
     point at which the Hessian will be evaluated.

     See also: odepkg.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
This function file can be used to approximate the Hessian of the
Hamiltonian in 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
bvp4c


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 690
 -- Function File: A = bvp4c (ODEFUN, BCFUN, SOLINIT)

     Solves the first order system of non-linear differential equations
     defined by ODEFUN with the boundary conditions defined in BCFUN.

     The structure SOLINIT defines the grid on which to compute the
     solution (SOLINIT.X), and an initial guess for the solution
     (SOLINIT.Y).  The output SOL is also a structure with the following
     fields:
        * SOL.X list of points where the solution is evaluated
        * SOL.Y solution evaluated at the points SOL.X
        * SOL.YP derivative of the solution evaluated at the points
          SOL.X
        * SOL.SOLVER = "bvp4c" for compatibility

     See also: odpkg.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Solves the first order system of non-linear differential equations
defined by OD



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
bwe_inexact_newton


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2262
 -- Command: [T_NEXT, X_NEXT] = bwe_inexact_newton (@FUN, T, X, DT,
          [OPTIONS])
 -- Command: [T_NEXT, X_NEXT, X_EST] = bwe_inexact_newton (@FUN, T, X,
          DT, [OPTIONS])

     This function can be used to integrate a set of non-stiff ordinary
     differential equations (non-stiff ODEs) with a given initial
     condition X from T to T+DT, with the Backward-Euler method using an
     inexact Newton method to solve the nonlinear system and estimating
     the error comparing the solution to that one given in two substeps
     by the Crank-Nicolson method.

     First output argument is the final integration time value.

     Second output parameter is the computed solution at time T_NEXT.

     Third output parameter is a solution of higher order for the
     estimation of the error.

     First input argument is the function describing the system of ODEs
     to be integrated.

     Second input parameter is the first extreme of integration
     interval.

     Third input argument is the initial condition of the system.

     Fourth input argument is the timestep, that is the length of the
     integration interval.

     Fifth input parameter is optional and describes a set of options
     useful to adapt the computation to what is needed.  Possible fields
     are
     'UseJacobian'
          is a switch variable ['YES','NO'] that tells the program how
          to set the 'JACOBIAN' option within optimset function,
     'NewtonTol'
          tolerance for termination test on residual,
     'MaxNewtonIterations'
          maximum number of nonlinear iterations,
     'Eta'
          initial forcing term (must be in the interval [0,1)).  For
          details see [1],
     'Choice'
          formula to use to select the forcing term may be 1 or 2,
          default value is 1.  For details see [1],
     'Algorithm'
          iterative method to solve the linearized system (default is
          ''GMRES''),
     'Restart'
          restart parameter for the GMRES solver (ignored for other
          solvers).

     References: [1] S.C. Eisenstat and H.F. Walker, "Choosing the
     Forcing Terms in an Inexact Newton Method."  SIAM Journal on
     Scientific Computing, 17(1), pp.  16-16, 1996.

See also: odepkg.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
This function can be used to integrate a set of non-stiff ordinary
differential 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
bwe_newton_raphson


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1772
 -- Command: [T_NEXT, X_NEXT] = bwe_newton_raphson (@FUN, T, X, DT,
          [OPTIONS])
 -- Command: [T_NEXT, X_NEXT, X_EST] = bwe_newton_raphson (@FUN, T, X,
          DT, [OPTIONS])

     This function can be used to integrate a set of non-stiff ordinary
     differential equations (non-stiff ODEs) with a given initial
     condition X from T to T+DT, with the Backward-Euler method using
     the Newton-Raphson method to solve the nonlinear system and
     estimating the error comparing the solution to that one given in
     two substeps by the same method.

     First output argument is the final integration time value.

     Second output parameter is the computed solution at time T_NEXT.

     Third output parameter is a higher order solution for the
     estimation of the error.

     First input argument is the function describing the system of ODEs
     to be integrated.

     Second input parameter is the first extreme of integration
     interval.

     Third input argument is the initial condition of the system.

     Fourth input argument is the timestep, that is the length of the
     integration interval.

     Fifth input parameter is optional and describes a set of options
     useful to adapt the computation to what is needed.  Possible fields
     are
     'NewtonTol'
          tolerance for termination test on residual,
     'MaxNewtonIterations'
          maximum number of nonlinear iterations,
     'Mass'
          a function_handle or a constant matrix defining the Mass
          matrix,
     'Jacobian'
          a function_handle defining the Jacobian,
     'havemasshandle'
          whether or not Mass is a function_handle,
     'massdependence'
          whether or not Mass depends on the solution.

See also: odepkg.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
This function can be used to integrate a set of non-stiff ordinary
differential 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
fuzzy_compare


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1560
 -- Command: [RES] = fuzzy_compare ("STRING1", STRING_SET,
          [CORRECTNESS])

     Compare a string with a set of strings and returns the positions in
     the set of strings at which there are the fields that best fit the
     one we are comparing.

     The distance used to compare the words is the Levenshtein distance
     and for more details see
     <http://en.wikipedia.org/wiki/Levenshtein_distance>.

     This function must be called with one output argument RES which
     contains the positions of the elements in STRING_SET which best fit
     the given word.  The tolerance that is used to determine if a field
     of the list fits or not the given word is a function of the length
     of the word and of the minimum distance of the word from all the
     elements of the list.  The more the length, the more the tolerance.
     The less the minimum, the less the tolerance but if the minimum is
     close to the length of the word, the tolerance must be small
     because it means that no field in the list is really fitting the
     given word.  So that the function is:

     tolerance = 2 * (length-minimum) * minimum / length.

     The first input argument must be a string containing the word to
     compare.

     The second input argument must be a vector of strings or a
     cell_array of strings and should contain the fields to use for the
     comparison.

     The third input argument is optional and represents a fixed
     tolerance that will replace the implemented one.

     See also: odeset,odeget,levenshtein.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compare a string with a set of strings and returns the positions in the
set of s



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
fwe_heun


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1256
 -- Command: [T_NEXT, X_NEXT] = fwe_heun (@FUN, T, X, DT, [OPTIONS])
 -- Command: [T_NEXT, X_NEXT, ERR] = fwe_heun (@FUN, T, X, DT,
          [OPTIONS])

     This function can be used to integrate a set of non-stiff ordinary
     differential equations (non-stiff ODEs) with a given initial
     condition X from T to T+DT, with the Forward-Euler method using the
     Heun-Euler method to estimate the error.  For the definition of
     this method see
     <http://en.wikipedia.org/wiki/List_of_Runge%E2%80%93Kutta_methods>.

     First output argument is the final integration time value.

     Second output parameter is the computed solution at time T_NEXT.

     Third output parameter is a higher order solution for the
     estimation of the error.

     First input argument is the function describing the system of ODEs
     to be integrated.

     Second input parameter is the first extreme of integration
     interval.

     Third input argument is the initial condition of the system.

     Fourth input argument is the timestep, that is the length of the
     integration interval.

     Fifth input parameter is optional and describes a set of options
     useful to adapt the computation to what is needed.

     See also: odepkg, ode12.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
This function can be used to integrate a set of non-stiff ordinary
differential 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
fwe_richardson


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1170
 -- Command: [T_NEXT, X_NEXT] = fwe_richardson (@FUN, T, X, DT,
          [OPTIONS])
 -- Command: [T_NEXT, X_NEXT, X_EST] = fwe_richardson (@FUN, T, X, DT,
          [OPTIONS])

     This function can be used to integrate a set of non-stiff ordinary
     differential equations (non-stiff ODEs) with a given initial
     condition X from T to T+DT, with the Forward-Euler method using the
     Richardson extrapolation method to estimate the error.

     First output argument is the final integration time value.

     Second output parameter is the computed solution at time T_NEXT.

     Third output parameter is a higher order solution for the
     estimation of the error.

     First input argument is the function describing the system of ODEs
     to be integrated.

     Second input parameter is the first extreme of integration
     interval.

     Third input argument is the initial condition of the system.

     Fourth input argument is the timestep, that is the length of the
     integration interval.

     Fifth input parameter is optional and describes a set of options
     useful to adapt the computation to what is needed.

     See also: odepkg.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
This function can be used to integrate a set of non-stiff ordinary
differential 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
golub_welsch


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1349
 -- Command: [NODES] = golub_welsch (M,N)
 -- Command: [NODES, WEIGHTS] = golub_welsch (M,N)
 -- Command: [NODES, WEIGHTS, VALUES] = golub_welsch (M,N)
 -- Command: [NODES, WEIGHTS, VALUES, DER] = golub_welsch (M,N)

     This function can be used to compute Gauss quadrature nodes and
     weights and values of Legendre polynomials (and their derivatives)
     at Gauss quadrature nodes just in one shot, whitout using an
     iterative method.  For all the theory about this topic see [1].

     First output parameter contains Gauss quadrature nodes in (-1,1).

     Second output argument contains computed Gauss quadrature weights.

     Third output parameter contains the values of Legendre polynomials
     at computed Gauss quadrature nodes.

     Fourth output argument contains the values of the derivatives of
     Legendre polynomials at Gauss quadrature nodes.

     First input argument must be a positive integer scalar and
     represents the maximum degree of Legendre polynomials.

     Second input argument must be a positive integer scalar and
     represents the Gauss quadrature order.

     References: [1] G.H. Golub and J.H. Welsch, "Calculation of Gauss
     Quadrature Rules."  Mathematics of computation, Vol.  23, No.  106
     (Apr.  1969), pp.  221-230+s1-s10, American Mathematical Society.

     See also: odepkg.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
This function can be used to compute Gauss quadrature nodes and weights
and valu



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
inexact_newton


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2302
 -- Command: [X, FVAL, EXITFLAG, OUTPUT, JACOBIAN] = inexact_newton
          (@FUN, X0, [OPTIONS])

     Solve the nonlinear equation 'f(x) = 0' using the inexact Newton
     method, starting from the initial guess X0.

     If an exact jacobian is not provided it is approximated by finite
     differences, if the method for solving linear systems is not
     specified it is set as defaults to 'GMRES', other possible values
     are 'PCG' or 'BICGSTAB'.

     First output parameter X is the computed solution.

     Second output parameter is @FVAL that is the value of the function
     at computed solution.

     Third output parameter is exitflag and it has not yet been
     implemented.

     Fourth output parameter is output which is a struct containing the
     field 'ITERATIONS' that is the number if iterations required to
     converge and 'FUNCCOUNT' which contains the number of function
     evaluations computed.

     Last output argument is jacobian and is the value of the Jacobian
     at the computed solution.

     The first input parameter @FUN must be a function_handle.

     The second input argument X0 must be the initial guess.

     The third input argument is optional and describes a set of options
     useful to adapt the computation to what is needed.  Possible fields
     are
     'UseJacobian'
          is a switch variable ['YES','NO'] that tells the program how
          to set the 'JACOBIAN' option within optimset function,
     'NewtonTol'
          tolerance for termination test on residual,
     'MaxNewtonIterations'
          maximum number of nonlinear iterations,
     'Eta'
          initial forcing term (must be in the interval [0,1)).  For
          details see [1],
     'Choice'
          formula to use to select the forcing term may be 1 or 2,
          default value is 1.  For details see [1],
     'Algorithm'
          iterative method to solve the linearized system (default is
          ''GMRES''),
     'Restart'
          restart parameter for the GMRES solver (ignored for other
          solvers).

     References: [1] S.C. Eisenstat and H.F. Walker, "Choosing the
     Forcing Terms in an Inexact Newton Method."  SIAM Journal on
     Scientific Computing, 17(1), pp.  16-16, 1996.

See also: gmres, pcg, bicgstab, odebwe.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Solve the nonlinear equation 'f(x) = 0' using the inexact Newton method,
startin



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
integrate_const


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1639
 -- Command: [T, Y] = integrate_const (@STEPPER,
     @FUN, TSPAN, X0, DT, OPTIONS)

     This function file can be called by an ODE solver function in order
     to integrate the set of ODEs on the interval [T0,T1] with a
     constant timestep DT.

     This function must be called with two output arguments: T and Y.
     Variable T is a column vector and contains the time stamps, instead
     Y is a matrix in which each column refers to a different unknown of
     the problem and the rows number is the same of T rows number so
     that each row of Y contains the values of all unknowns at the time
     value contained in the corresponding row in T.

     The first input argument must be a function_handle or an inline
     function representing the stepper, that is the function responsible
     for step-by-step integration.  This function discriminates one
     method from the others.

     The second input argument is the order of the stepper.  It is
     needed to compute the adaptive timesteps.

     The third input argument is a function_handle or an inline function
     that defines the set of ODE:

     y' = f(t,y).

     The third input argument is the time vector which defines
     integration interval, that is [TSPAN(1),TSPAN(END)] and all the
     intermediate elements are taken as times at which the solution is
     required.

     The fourth argument contains the initial conditions for the ODEs.

     The fifth input argument represents the fixed timestep and the last
     input argument contains some options that may be needed for the
     stepper.

See also: integrate_adaptive, integrate_n_steps.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 29
@FUN, TSPAN, X0, DT, OPTIONS)



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 17
integrate_n_steps


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1592
 -- Command: [T, Y] = integrate_n_steps
     (@STEPPER, @FUN, T0, X0, DT, N, OPTIONS)

     This function file can be called by an ODE solver function in order
     to integrate the set of ODEs on the interval [T0,T0 + N*DT] with a
     constant timestep dt and on a fixed number of steps.

     This function must be called with two output arguments: T and Y.
     Variable T is a column vector and contains the time stamps, instead
     Y is a matrix in which each column refers to a different unknown of
     the problem and the rows number is the same of T rows number so
     that each row of Y contains the values of all unknowns at the time
     value contained in the corresponding row in T.

     The first input argument must be a function_handle or an inline
     function representing the stepper, that is the function responsible
     for step-by-step integration.  This function discriminates one
     method from the others.

     The second input argument is the order of the stepper.  It is
     needed to compute the adaptive timesteps.

     The third input argument is a function_handle or an inline function
     that defines the set of ODE:

     y' = f(t,y).

     The third input argument is the starting point for the integration.

     The fourth argument contains the initial conditions for the ODEs.

     The fifth input argument represents the fixed timestep while the
     sixth contains the number of integration steps.

     The last argument is a struct with the options that may be needed
     by the stepper.

See also: integrate_adaptive, integrate_const.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
(@STEPPER, @FUN, T0, X0, DT, N, OPTIONS)



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
levenshtein


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 912
 -- Command: [DIST] = levenshtein ("STRING1", "STRING2", [UPPER_BOUND])
 -- Command: [DIST, D] = levenshtein ("STRING1", "STRING2",
          [UPPER_BOUND])

     This function file can be used to compare two strings and it uses
     the Levenshtein distance as definition of metric between strings.
     More details at
     <http://en.wikipedia.org/wiki/Levenshtein_distance>.

     This function must be called with two output arguments: DIST is the
     distance between the two strings and D is the matrix computed by
     Levenshtein algorithm.

     The first and the second input arguments are the two strings to be
     compared.  This comparison is case-sensitive.

     The third argument is optional and fixes an upper bound for the
     distance.  If the distance is greater than this limit then the
     function ends and returns a value equal to Inf.

     See also: odeset, odeget, fuzzy_compare.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
This function file can be used to compare two strings and it uses the
Levenshtei



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
ode12


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3152
 -- Function File: [T, Y] = ode12 (FUN, TRANGE, INIT)
 -- Function File: [T, Y] = ode12 (FUN, TRANGE, INIT, ODE_OPT)
 -- Function File: [T, Y] = ode12 (..., PAR1, PAR2, ...)
 -- Function File: [T, Y, TE, YE, IE] = ode12 (...)
 -- Function File: SOLUTION = ode12 (...)

     Solve a set of non-stiff Ordinary Differential Equations (non-stiff
     ODEs) with the well known explicit Heun-Euler method of order 1.
     For the definition of this method see
     <http://en.wikipedia.org/wiki/List_of_Runge%E2%80%93Kutta_methods>.

     FUN is a function handle, inline function, or string containing the
     name of the function that defines the ODE: 'y' = f(t,y)'.  The
     function must accept two inputs where the first is time T and the
     second is a column vector of unknowns Y.

     TRANGE specifies the time interval over which the ODE will be
     evaluated.  Typically, it is a two-element vector specifying the
     initial and final times ('[tinit, tfinal]').  If there are more
     than two elements then the solution will also be evaluated at these
     intermediate time instances using an interpolation procedure of the
     same order as the one of the solver.

     By default, 'ode12' uses an adaptive timestep with the
     'integrate_adaptive' algorithm.  The tolerance for the timestep
     computation may be changed by using the options '"RelTol"' and
     '"AbsTol"'.

     INIT contains the initial value for the unknowns.  If it is a row
     vector then the solution Y will be a matrix in which each column is
     the solution for the corresponding initial value in INIT.

     The optional fourth argument ODE_OPT specifies non-default options
     to the ODE solver.  It is a structure generated by 'odeset'.
     'ode12' will ignore the following options: "BDF", "InitialSlope",
     "Jacobian", "JPattern", "MassSingular", "MaxOrder", "MvPattern",
     "Vectorized".

     The function typically returns two outputs.  Variable T is a column
     vector and contains the times where the solution was computed.  The
     output Y is a matrix in which each column refers to a different
     unknown of the problem and each row corresponds to a time in T.  If
     TRANGE specifies intermediate time steps, only those will be
     returned.

     The output can also be returned as a structure SOLUTION which has a
     field X containing a row vector of times where the solution was
     evaluated and a field Y containing the solution matrix such that
     each column corresponds to a time in X.  Use 'fieldnames
     (SOLUTION)' to see the other fields and additional information
     returned.

     If using the '"Events"' option then three additional outputs may be
     returned.  TE holds the time when an Event function returned a
     zero.  YE holds the value of the solution at time TE.  IE contains
     an index indicating which Event function was triggered in the case
     of multiple Event functions.

     Example: Solve the Van der Pol equation

          fvdp = @(T,Y) [Y(2); (1 - Y(1)^2) * Y(2) - Y(1)];
          [T,Y] = ode12 (fvdp, [0, 20], [2, 0]);

     See also: odeset, ode23, ode45, ode78.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Solve a set of non-stiff Ordinary Differential Equations (non-stiff
ODEs) with t



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
ode23d


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4034
 -- [T, Y] = ode23d (FUN, TRANGE, INIT, LAGS, HISTORY)
 -- [T, Y] = ode23d (FUN, TRANGE, INIT, LAGS, HISTORY, ODE_OPT)
 -- [T, Y, TE, YE, IE] = ode23d (...)
 -- SOLUTION = ode23d (...)

     This function file can be used to solve a set of non-stiff delay
     differential equations (non-stiff DDEs) with a modified version of
     the well known explicit Runge-Kutta method of order 3.

     FUN is a function handle, inline function, or string containing the
     name of the function that defines the ODE: 'y' = f(t,y)'.  The
     function must accept two inputs where the first is time T and the
     second is a column vector of unknowns Y.

     TRANGE specifies the time interval over which the ODE will be
     evaluated.  Typically, it is a two-element vector specifying the
     initial and final times ('[tinit, tfinal]').  If there are more
     than two elements then the solution will also be evaluated at these
     intermediate time instances using an interpolation procedure of the
     same order as the one of the solver.

     INIT contains the initial value for the unknowns.  If it is a row
     vector then the solution Y will be a matrix in which each column is
     the solution for the corresponding initial value in INIT.

     LAGS is a vector that describes the lags of time.

     HISTORY is a matrix and describes the history of the DDEs.

     The optional fourth argument ODE_OPT specifies non-default options
     to the ODE solver.  It is a structure generated by 'odeset'.
     'ode23d' will ignore the following options: "BDF", "InitialSlope",
     "Jacobian", "JPattern", "MassSingular", "MaxOrder", "MvPattern",
     "Vectorized".

     The function typically returns two outputs.  Variable T is a column
     vector and contains the times where the solution was computed.  The
     output Y is a matrix in which each column refers to a different
     unknown of the problem and each row corresponds to a time in T.  If
     TRANGE specifies intermediate time steps, only those will be
     returned.

     The output can also be returned as a structure SOLUTION which has
     field X containing the time where the solution was evaluated and
     field Y containing the solution matrix for the times in X.  Use
     'fieldnames (SOLUTION)' to see the other fields and additional
     information returned.

     If using the '"Events"' option then three additional outputs may be
     returned.  TE holds the time when an Event function returned a
     zero.  YE holds the value of the solution at time TE.  IE contains
     an index indicating which Event function was triggered in the case
     of multiple Event functions.

     In other words, this function will solve a problem of the form
          dy/dt = fun (t, y(t), y(t-lags(1), y(t-lags(2), ...)))
          y(slot(1)) = init
          y(slot(1)-lags(1)) = hist(1), y(slot(1)-lags(2)) = hist(2), ...

     For example:
        - the following code solves an anonymous implementation of a
          chaotic behavior

               fcao = @(vt, vy, vz) [2 * vz / (1 + vz^9.65) - vy];

               vopt = odeset ("NormControl", "on", "RelTol", 1e-3);
               vsol = ode23d (fcao, [0, 100], 0.5, 2, 0.5, vopt);

               vlag = interp1 (vsol.x, vsol.y, vsol.x - 2);
               plot (vsol.y, vlag); legend ("fcao (t,y,z)");

        - to solve the following problem with two delayed state
          variables

               d y1(t)/dt = -y1(t)
               d y2(t)/dt = -y2(t) + y1(t-5)
               d y3(t)/dt = -y3(t) + y2(t-10)*y1(t-10)

          one might do the following

               function f = fun (t, y, yd)
               f(1) = -y(1);                   %% y1' = -y1(t)
               f(2) = -y(2) + yd(1,1);         %% y2' = -y2(t) + y1(t-lags(1))
               f(3) = -y(3) + yd(2,2)*yd(1,2); %% y3' = -y3(t) + y2(t-lags(2))*y1(t-lags(2))
               end
               T = [0,20]
               res = ode23d (@fun, T, [1;1;1], [5, 10], ones (3,2));

     See also: odeset, ode45d, ode78d.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
This function file can be used to solve a set of non-stiff delay
differential eq



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
ode23s


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3344
 -- Function File: [T, Y] = ode23s (FUN, TRANGE, INIT)
 -- Function File: [T, Y] = ode23s (FUN, TRANGE, INIT, ODE_OPT)
 -- Function File: [T, Y] = ode23s (..., PAR1, PAR2, ...)
 -- Function File: [T, Y, TE, YE, IE] = ode23s (...)
 -- Function File: SOLUTION = ode23s (...)

     Solve a set of stiff ordinary differential (stiff ODEs) equations
     with a Rosenbrock method of order (2,3).  For the definition of
     this method see "The MATLAB ode suite", L.F. Shampine, mass.W.
     Reichelt, pp.6-7

     FUN is a function handle, inline function, or string containing the
     name of the function that defines the ODE: 'M y' = f(t,y)'.  The
     function must accept two inputs where the first is time T and the
     second is a column vector of unknowns Y.  M is a costant mass
     matrix, non-singular and possibly sparse.  Set the field MASS in
     ODEOPTS using ODESET to specify a mass matrix.

     TRANGE specifies the time interval over which the ODE will be
     evaluated.  Typically, it is a two-element vector specifying the
     initial and final times ('[tinit, tfinal]').  If there are more
     than two elements then the solution will also be evaluated at these
     intermediate time instances using an interpolation procedure of the
     same order as the one of the solver.

     By default, 'ode23s' uses an adaptive timestep with the
     'integrate_adaptive' algorithm.  The tolerance for the timestep
     computation may be changed by using the options '"RelTol"' and
     '"AbsTol"'.

     INIT contains the initial value for the unknowns.  If it is a row
     vector then the solution Y will be a matrix in which each column is
     the solution for the corresponding initial value in INIT.

     The optional fourth argument ODE_OPT specifies non-default options
     to the ODE solver.  It is a structure generated by 'odeset'.
     'ode23s' will ignore the following options: "BDF", "InitialSlope",
     "MassSingular", "MStateDependence", "MvPattern", "MaxOrder",
     "NonNegative".

     The function typically returns two outputs.  Variable T is a column
     vector and contains the times where the solution was computed.  The
     output Y is a matrix in which each column refers to a different
     unknown of the problem and each row corresponds to a time in T.  If
     TRANGE specifies intermediate time steps, only those will be
     returned.

     The output can also be returned as a structure SOLUTION which has a
     field X containing a row vector of times where the solution was
     evaluated and a field Y containing the solution matrix such that
     each column corresponds to a time in X.  Use 'fieldnames
     (SOLUTION)' to see the other fields and additional information
     returned.

     If using the '"Events"' option then three additional outputs may be
     returned.  TE holds the time when an Event function returned a
     zero.  YE holds the value of the solution at time TE.  IE contains
     an index indicating which Event function was triggered in the case
     of multiple Event functions.  .  Example: Solve the stiff Van der
     Pol equation

          f = @(T,Y) [Y(2); 1000*(1 - Y(1)^2) * Y(2) - Y(1)];
          opt = odeset ('Mass', [1 0; 0 1], 'MaxStep', 1e-1);
          [vt, vy] = ode23s (f, [0 2000], [2 0], opt);

     See also: odeset, daspk, dassl.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Solve a set of stiff ordinary differential (stiff ODEs) equations with a
Rosenbr



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
ode45d


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4004
 -- [T, Y] = ode45d (FUN, TRANGE, INIT, LAGS, HISTORY)
 -- [T, Y] = ode45d (FUN, TRANGE, INIT, LAGS, HISTORY, ODE_OPT)
 -- [T, Y, TE, YE, IE] = ode45d (...)
 -- SOLUTION = ode45d (...)

     Solve a set of non-stiff delay differential equations (non-stiff
     DDEs) with a modified version of the well known explicit
     Runge-Kutta method of order (4,5).

     FUN is a function handle, inline function, or string containing the
     name of the function that defines the ODE: 'y' = f(t,y)'.  The
     function must accept two inputs where the first is time T and the
     second is a column vector of unknowns Y.

     TRANGE specifies the time interval over which the ODE will be
     evaluated.  Typically, it is a two-element vector specifying the
     initial and final times ('[tinit, tfinal]').  If there are more
     than two elements then the solution will also be evaluated at these
     intermediate time instances using an interpolation procedure of the
     same order as the one of the solver.

     INIT contains the initial value for the unknowns.  If it is a row
     vector then the solution Y will be a matrix in which each column is
     the solution for the corresponding initial value in INIT.

     LAGS is a vector that describes the lags of time.

     HISTORY is a matrix and describes the history of the DDEs.

     The optional fourth argument ODE_OPT specifies non-default options
     to the ODE solver.  It is a structure generated by 'odeset'.
     'ode45d' will ignore the following options: "BDF", "InitialSlope",
     "Jacobian", "JPattern", "MassSingular", "MaxOrder", "MvPattern",
     "Vectorized".

     The function typically returns two outputs.  Variable T is a column
     vector and contains the times where the solution was computed.  The
     output Y is a matrix in which each column refers to a different
     unknown of the problem and each row corresponds to a time in T.  If
     TRANGE specifies intermediate time steps, only those will be
     returned.

     The output can also be returned as a structure SOLUTION which has
     field X containing the time where the solution was evaluated and
     field Y containing the solution matrix for the times in X.  Use
     'fieldnames (SOLUTION)' to see the other fields and additional
     information returned.

     If using the '"Events"' option then three additional outputs may be
     returned.  TE holds the time when an Event function returned a
     zero.  YE holds the value of the solution at time TE.  IE contains
     an index indicating which Event function was triggered in the case
     of multiple Event functions.

     In other words, this function will solve a problem of the form
          dy/dt = fun (t, y(t), y(t-lags(1), y(t-lags(2), ...)))
          y(slot(1)) = init
          y(slot(1)-lags(1)) = hist(1), y(slot(1)-lags(2)) = hist(2), ...

     For example:
        - the following code solves an anonymous implementation of a
          chaotic behavior

               fcao = @(vt, vy, vz) [2 * vz / (1 + vz^9.65) - vy];

               vopt = odeset ("NormControl", "on", "RelTol", 1e-3);
               vsol = ode45d (fcao, [0, 100], 0.5, 2, 0.5, vopt);

               vlag = interp1 (vsol.x, vsol.y, vsol.x - 2);
               plot (vsol.y, vlag); legend ("fcao (t,y,z)");

        - to solve the following problem with two delayed state
          variables

               d y1(t)/dt = -y1(t)
               d y2(t)/dt = -y2(t) + y1(t-5)
               d y3(t)/dt = -y3(t) + y2(t-10)*y1(t-10)

          one might do the following

               function f = fun (t, y, yd)
               f(1) = -y(1);                   %% y1' = -y1(t)
               f(2) = -y(2) + yd(1,1);         %% y2' = -y2(t) + y1(t-lags(1))
               f(3) = -y(3) + yd(2,2)*yd(1,2); %% y3' = -y3(t) + y2(t-lags(2))*y1(t-lags(2))
               end
               T = [0,20]
               res = ode45d (@fun, T, [1;1;1], [5, 10], ones (3,2));

     See also: odeset, ode23d, ode78d.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Solve a set of non-stiff delay differential equations (non-stiff DDEs)
with a mo



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
ode78


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3080
 -- Function File: [T, Y] = ode78 (FUN, TRANGE, INIT)
 -- Function File: [T, Y] = ode78 (FUN, TRANGE, INIT, ODE_OPT)
 -- Function File: [T, Y] = ode78 (..., PAR1, PAR2, ...)
 -- Function File: [T, Y, TE, YE, IE] = ode78 (...)
 -- Function File: SOLUTION = ode78 (...)

     Solve a set of non-stiff Ordinary Differential Equations (non-stiff
     ODEs) or non-stiff differential algebraic equations (non-stiff
     DAEs) with the well known explicit Runge-Kutta method of order 7.

     FUN is a function handle, inline function, or string containing the
     name of the function that defines the ODE: 'y' = f(t,y)'.  The
     function must accept two inputs where the first is time T and the
     second is a column vector of unknowns Y.

     TRANGE specifies the time interval over which the ODE will be
     evaluated.  Typically, it is a two-element vector specifying the
     initial and final times ('[tinit, tfinal]').  If there are more
     than two elements then the solution will also be evaluated at these
     intermediate time instances using a Hermite interpolation procedure
     of order 3.

     By default, 'ode78' uses an adaptive timestep with the
     'integrate_adaptive' algorithm.  The tolerance for the timestep
     computation may be changed by using the options '"RelTol"' and
     '"AbsTol"'.

     INIT contains the initial value for the unknowns.  If it is a row
     vector then the solution Y will be a matrix in which each column is
     the solution for the corresponding initial value in INIT.

     The optional fourth argument ODE_OPT specifies non-default options
     to the ODE solver.  It is a structure generated by 'odeset'.
     'ode78' will ignore the following options: "BDF", "InitialSlope",
     "Jacobian", "JPattern", "MassSingular", "MaxOrder", "MvPattern",
     "Vectorized".

     The function typically returns two outputs.  Variable T is a column
     vector and contains the times where the solution was computed.  The
     output Y is a matrix in which each column refers to a different
     unknown of the problem and each row corresponds to a time in T.  If
     TRANGE specifies intermediate time steps, only those will be
     returned.

     The output can also be returned as a structure SOLUTION which has a
     field X containing a row vector of times where the solution was
     evaluated and a field Y containing the solution matrix such that
     each column corresponds to a time in X.  Use 'fieldnames
     (SOLUTION)' to see the other fields and additional information
     returned.

     If using the '"Events"' option then three additional outputs may be
     returned.  TE holds the time when an Event function returned a
     zero.  YE holds the value of the solution at time TE.  IE contains
     an index indicating which Event function was triggered in the case
     of multiple Event functions.

     Example: Solve the Van der Pol equation

          fvdp = @(T,Y) [Y(2); (1 - Y(1)^2) * Y(2) - Y(1)];
          [T,Y] = ode78 (fvdp, [0, 20], [2, 0]);

     See also: odeset, ode78, ode23, ode78.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Solve a set of non-stiff Ordinary Differential Equations (non-stiff
ODEs) or non



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
ode78d


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3969
 -- [T, Y] = ode78d (FUN, TRANGE, INIT, LAGS, HISTORY)
 -- [T, Y] = ode78d (FUN, TRANGE, INIT, LAGS, HISTORY, ODE_OPT)
 -- [T, Y, TE, YE, IE] = ode78d (...)
 -- SOLUTION = ode78d (...)

     Solve a set of non-stiff delay differential equations (non-stiff
     DDEs) with a modified version of the well known explicit
     Runge-Kutta method of order (7,8).

     FUN is a function handle, inline function, or string containing the
     name of the function that defines the ODE: 'y' = f(t,y)'.  The
     function must accept two inputs where the first is time T and the
     second is a column vector of unknowns Y.

     TRANGE specifies the time interval over which the ODE will be
     evaluated.  Typically, it is a two-element vector specifying the
     initial and final times ('[tinit, tfinal]').  If there are more
     than two elements then the solution will also be evaluated at these
     intermediate time instances using a Hermite interpolation of order
     3.

     INIT contains the initial value for the unknowns.  If it is a row
     vector then the solution Y will be a matrix in which each column is
     the solution for the corresponding initial value in INIT.

     LAGS is a vector that describes the lags of time.

     HISTORY is a matrix and describes the history of the DDEs.

     The optional fourth argument ODE_OPT specifies non-default options
     to the ODE solver.  It is a structure generated by 'odeset'.
     'ode78d' will ignore the following options: "BDF", "InitialSlope",
     "Jacobian", "JPattern", "MassSingular", "MaxOrder", "MvPattern",
     "Vectorized".

     The function typically returns two outputs.  Variable T is a column
     vector and contains the times where the solution was computed.  The
     output Y is a matrix in which each column refers to a different
     unknown of the problem and each row corresponds to a time in T.  If
     TRANGE specifies intermediate time steps, only those will be
     returned.

     The output can also be returned as a structure SOLUTION which has
     field X containing the time where the solution was evaluated and
     field Y containing the solution matrix for the times in X.  Use
     'fieldnames (SOLUTION)' to see the other fields and additional
     information returned.

     If using the '"Events"' option then three additional outputs may be
     returned.  TE holds the time when an Event function returned a
     zero.  YE holds the value of the solution at time TE.  IE contains
     an index indicating which Event function was triggered in the case
     of multiple Event functions.

     In other words, this function will solve a problem of the form
          dy/dt = fun (t, y(t), y(t-lags(1), y(t-lags(2), ...)))
          y(slot(1)) = init
          y(slot(1)-lags(1)) = hist(1), y(slot(1)-lags(2)) = hist(2), ...

     For example:
        - the following code solves an anonymous implementation of a
          chaotic behavior

               fcao = @(vt, vy, vz) [2 * vz / (1 + vz^9.65) - vy];

               vopt = odeset ("NormControl", "on", "RelTol", 1e-3);
               vsol = ode78d (fcao, [0, 100], 0.5, 2, 0.5, vopt);

               vlag = interp1 (vsol.x, vsol.y, vsol.x - 2);
               plot (vsol.y, vlag); legend ("fcao (t,y,z)");

        - to solve the following problem with two delayed state
          variables

               d y1(t)/dt = -y1(t)
               d y2(t)/dt = -y2(t) + y1(t-5)
               d y3(t)/dt = -y3(t) + y2(t-10)*y1(t-10)

          one might do the following

               function f = fun (t, y, yd)
               f(1) = -y(1);                   %% y1' = -y1(t)
               f(2) = -y(2) + yd(1,1);         %% y2' = -y2(t) + y1(t-lags(1))
               f(3) = -y(3) + yd(2,2)*yd(1,2); %% y3' = -y3(t) + y2(t-lags(2))*y1(t-lags(2))
               end
               T = [0,20]
               res = ode78d (@fun, T, [1;1;1], [5, 10], ones (3,2));

     See also: odeset, ode23d, ode45d.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Solve a set of non-stiff delay differential equations (non-stiff DDEs)
with a mo



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
odeRATTLE


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5902
 -- Function File: [T, Y] = odeRATTLE (FUN, CONSTR, TRANGE, INIT)
 -- Function File: [T, Y] = odeRATTLE (FUN, CONSTR, TRANGE, INIT,
          ODE_OPT)
 -- Function File: [T, Y] = odeRATTLE (..., PAR1, PAR2, ...)
 -- Function File: [T, Y, TE, YE, IE] = odeRATTLE (...)
 -- Function File: SOLUTION = odeRATTLE (...)

     This function is a geometric integrator for constrained Hamilton's
     equations of motion that uses the RATTLE method of order 2 to find
     the new solution, step by step.

     FUN is a function_handle or an inline function that defines the
     system q' = dH/dp (t,[q;p]) p' = -dH/dq (t,[q;p]), where H(t,[q;p])
     is the Hamiltonian of the problem, q are generalized coordinates
     and p are generalized momenta.  This function must take two input
     arguments: the time and the unknowns.  It must return a vector or a
     cell (if the Hamiltonian Hessian is passed to speedup computations)
     containing as first element the Hamilton's equations of motion (the
     previous system of equations) and as second element the Hessian of
     the Hamiltonian.

     CONSTR is a function_handle or an inline function that defines the
     constraints of the problem g(q)=0.  This function must take one
     input argument and must return a vector or a cell (if the
     constraint gradient and constraint Hessian are passed) containing
     as first element the equations defining the holonomic constraints
     and as second and third elements respectively the gradient and the
     Hessian of this constraints function (this is not mandatory but it
     can speedup the computation and improve accuracy).

     TRANGE specifies the time interval over which the ODE will be
     evaluated.  Typically, it is a two-element vector specifying the
     initial and final times ('[tinit, tfinal]').  If there are more
     than two elements then the solution will also be evaluated at these
     intermediate time instances using linear interpolation.

     By default, 'odeRATTLE' uses an adaptive timestep with the
     'integrate_adaptive' algorithm.  The tolerance for the timestep
     computation may be changed by using the options '"RelTol"' and
     '"AbsTol"'.

     INIT contains the initial value for the unknowns.  It is a row or
     column vector containing the generalized coordinates in its first
     half and the generalized momenta in the second half.  Each momentum
     correspond to the coordinate with the same relative position inside
     the vector of initial conditions.

     The optional fourth argument ODE_OPT specifies non-default options
     to the ODE solver.  It is a structure generated by 'odeset'.
     'ode12' will ignore the following options: "BDF", "InitialSlope",
     "Jacobian", "JPattern", "MassSingular", "MaxOrder", "MvPattern",
     "Vectorized".  The user can set extra options by adding fields to
     the structure.  'odeRATTLE' allows for:

     NewtonTol
          the tolerance for the Newton algorithm [Default = 1e-7].

     MaxNewtonIterations
          maximum number of Newton iterations [Default = 100].

     InexactSolver
          the Newton solver.  It can be set to either
          ["newton_raphson"], "inexact_newton" or "fsolve".

     ConstraintFcn
          function_handle representing the constraints of the system.

     ConstraintGradFcn
          function_handle representing the gradient of the constraints
          of the system.

     ConstraintHessFcn
          function_handle representing the Hessian of the Hamiltonian of
          the system,

     ConstraintsNb
          positive integer equal to the number of constraints of the
          system.

     HamiltonianHessFcn
          function_handle representing the Hessian of the Hamiltonian of
          the system.

     If the "inexact_newton" solver is set, a further set of options can
     be provided:

     UseJacobian
          It can be set to either "yes" or ["no].  In the first case,
          the Hamiltonian Hessian, the constraint gradient and the
          constraint Hessian will be used.  If they are not provided,
          they will be approximated by the utility functions
          'approx_Hamilt_Hess', 'approx_Constr_grad' and
          'approx_Constr_Hess'.

     Eta
          initial forcing term (must be in the interval [0,1)).  The
          dafault value is set to 0.5.  For details see [1].

     Choice
          select the forcing term.  It can be 1 (Default) or 2.  For
          details see [1].

     Algorithm
          iterative method to solve the linearized system.  It can be
          ["gmres"], "pcg" or "bicgstab".

     Restart
          restart parameter for the GMRES solver (ignored for other
          solvers).  [Default = 20].

     The function typically returns two outputs.  Variable T is a column
     vector and contains the times where the solution was found.  The
     output Y is a matrix in which each column refers to a different
     unknown of the problem and each row corresponds to a time in T.

     The output can also be returned as a structure SOLUTION which has
     field X containing the time where the solution was evaluated and
     field Y containing the solution matrix for the times in X.  Use
     'fieldnames (SOLUTION)' to see the other fields and additional
     information returned.

     If using the '"Events"' option then three additional outputs may be
     returned.  TE holds the time when an Event function returned a
     zero.  YE holds the value of the solution at time TE.  IE contains
     an index indicating which Event function was triggered in the case
     of multiple Event functions.

     References:

     [1] S.C. Eisenstat and H.F. Walker, "Choosing the Forcing Terms in
     an Inexact Newton Method."  SIAM Journal on Scientific Computing,
     17(1), pp.  16-16, 1996.

     See also: odeset, odeSE, odeSPVI, odeSV, odeVV.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
This function is a geometric integrator for constrained Hamilton's
equations of 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
odeSE


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4919
 -- Function File: [T, Y] = odeSE (FUN, TRANGE, INIT)
 -- Function File: [T, Y] = odeSE (FUN, TRANGE, INIT, ODE_OPT)
 -- Function File: [T, Y] = odeSE (..., PAR1, PAR2, ...)
 -- Function File: [T, Y, TE, YE, IE] = odeSE (...)
 -- Function File: SOLUTION = odeSE (...)

     This function is a geometric integrator for Hamilton's equations of
     motion that uses the Symplectic-Euler method of order 1 (also known
     as Semi-implicit Euler method) to find the new solution, step by
     step.

     FUN is a function_handle or an inline function that defines the
     system q' = dH/dp (t,[q;p]) p' = -dH/dq (t,[q;p]), where H(t,[q;p])
     is the Hamiltonian of the problem, q are generalized coordinates
     and p are generalized momenta.  This function must take two input
     arguments: the time and the unknowns.  It must return a vector or a
     cell (if the Hamiltonian Hessian is passed to speedup computations)
     containing as first element the Hamilton's equations of motion (the
     previous system of equations) and as second element the Hessian of
     the Hamiltonian.

     TRANGE specifies the time interval over which the ODE will be
     evaluated.  Typically, it is a two-element vector specifying the
     initial and final times ('[tinit, tfinal]').  If there are more
     than two elements then the solution will also be evaluated at these
     intermediate time instances using linear interpolation.

     By default, 'odeSE' uses an adaptive timestep with the
     'integrate_adaptive' algorithm.  The tolerance for the timestep
     computation may be changed by using the options '"RelTol"' and
     '"AbsTol"'.

     INIT contains the initial value for the unknowns.  It is a row or
     column vector containing the generalized coordinates in its first
     half and the generalized momenta in the second half.  Each momentum
     correspond to the coordinate with the same relative position inside
     the vector of initial conditions.

     The optional fourth argument ODE_OPT specifies non-default options
     to the ODE solver.  It is a structure generated by 'odeset'.
     'ode12' will ignore the following options: "BDF", "InitialSlope",
     "Jacobian", "JPattern", "MassSingular", "MaxOrder", "MvPattern",
     "Vectorized".  The user can set extra options by adding fields to
     the structure.  'odeSE' allows for:

     NewtonTol
          the tolerance for the Newton algorithm [Default = 1e-7].

     MaxNewtonIterations
          maximum number of Newton iterations [Default = 100].

     InexactSolver
          the Newton solver.  It can be set to either
          ["newton_raphson"], "inexact_newton" or "fsolve".

     Explicit
          It can be set to either "yes" or ["no].  If the system is
          explicit, the computation will be faster

     If the "inexact_newton" solver is set, a further set of options can
     be provided:

     UseJacobian
          It can be set to either "yes" or ["no].  In the first case,
          the Hamiltonian Hessian, the constraint gradient and the
          constraint Hessian will be used.  If they are not provided,
          they will be approximated by the utility functions
          'approx_Hamilt_Hess', 'approx_Constr_grad' and
          'approx_Constr_Hess'.

     Eta
          initial forcing term (must be in the interval [0,1)).  The
          dafault value is set to 0.5.  For details see [1].

     Choice
          select the forcing term.  It can be 1 (Default) or 2.  For
          details see [1].

     Algorithm
          iterative method to solve the linearized system.  It can be
          ["gmres"], "pcg" or "bicgstab".

     Restart
          restart parameter for the GMRES solver (ignored for other
          solvers).  [Default = 20].

     The function typically returns two outputs.  Variable T is a column
     vector and contains the times where the solution was found.  The
     output Y is a matrix in which each column refers to a different
     unknown of the problem and each row corresponds to a time in T.

     The output can also be returned as a structure SOLUTION which has
     field X containing the time where the solution was evaluated and
     field Y containing the solution matrix for the times in X.  Use
     'fieldnames (SOLUTION)' to see the other fields and additional
     information returned.

     If using the '"Events"' option then three additional outputs may be
     returned.  TE holds the time when an Event function returned a
     zero.  YE holds the value of the solution at time TE.  IE contains
     an index indicating which Event function was triggered in the case
     of multiple Event functions.

     References:

     [1] S.C. Eisenstat and H.F. Walker, "Choosing the Forcing Terms in
     an Inexact Newton Method."  SIAM Journal on Scientific Computing,
     17(1), pp.  16-16, 1996.

     See also: odeset, odefwe, inexact_newton.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
This function is a geometric integrator for Hamilton's equations of
motion that 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
odeSPVI


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5134
 -- Command: [SOL] = odeSPVI (@FUN, SLOT, INIT, [OPT], [PAR1, PAR2,
          ...])
 -- Command: [T, Y, [XE, YE, IE]] = odeSPVI (@FUN, SLOT, INIT, [OPT],
          [PAR1, PAR2, ...])

     This function is a geometric integrator for Hamilton's equations of
     motion that uses the spectral variational integrators method to
     find the new solution, step by step.

     This function can be called with two output arguments: T and Y.
     Variable T is a column vector and contains the time stamps, instead
     Y is a matrix in which each column refers to a different unknown of
     the problem and the rows number is the same of T rows number so
     that each row of Y contains the values of all unknowns at the time
     value contained in the corresponding row in T.

     FUN is a function_handle or an inline function that defines the
     system q' = dH/dp (t,[q;p]) p' = -dH/dq (t,[q;p]), where H(t,[q;p])
     is the Hamiltonian of the problem, q are generalized coordinates
     and p are generalized momenta.  This function must take two input
     arguments: the time and the unknowns.  It must return a vector or a
     cell (if the Hamiltonian Hessian is passed to speedup computations)
     containing as first element the Hamilton's equations of motion (the
     previous system of equations) and as second element the Hessian of
     the Hamiltonian.

     TRANGE specifies the time interval over which the ODE will be
     evaluated.  Typically, it is a two-element vector specifying the
     initial and final times ('[tinit, tfinal]').  If there are more
     than two elements then the solution will also be evaluated at these
     intermediate time instances through interpolation

     By default, 'odeSPVI' uses an adaptive timestep with the
     'integrate_adaptive' algorithm.  The tolerance for the timestep
     computation may be changed by using the options '"RelTol"' and
     '"AbsTol"'.

     INIT contains the initial value for the unknowns.  It is a row or
     column vector containing the generalized coordinates in its first
     half and the generalized momenta in the second half.  Each momentum
     correspond to the coordinate with the same relative position inside
     the vector of initial conditions.

     The optional fourth argument ODE_OPT specifies non-default options
     to the ODE solver.  It is a structure generated by 'odeset'.
     'ode12' will ignore the following options: "BDF", "InitialSlope",
     "Jacobian", "JPattern", "MassSingular", "MaxOrder", "MvPattern",
     "Vectorized".  The user can set extra options by adding fields to
     the structure.  'odeSPVI' allows for:

     NewtonTol
          the tolerance for the Newton algorithm [Default = 1e-7].

     MaxNewtonIterations
          maximum number of Newton iterations [Default = 100].

     InexactSolver
          the Newton solver.  It can be set to either
          ["newton_raphson"], "inexact_newton" or "fsolve".

     PolynomialDegree
          The polynomial degree [Default = 1].

     If the "inexact_newton" solver is set, a further set of options can
     be provided:

     UseJacobian
          It can be set to either "yes" or ["no].  In the first case,
          the Hamiltonian Hessian, the constraint gradient and the
          constraint Hessian will be used.  If they are not provided,
          they will be approximated by the utility functions
          'approx_Hamilt_Hess', 'approx_Constr_grad' and
          'approx_Constr_Hess'.

     Eta
          initial forcing term (must be in the interval [0,1)).  The
          dafault value is set to 0.5.  For details see [1].

     Choice
          select the forcing term.  It can be 1 (Default) or 2.  For
          details see [1].

     Algorithm
          iterative method to solve the linearized system.  It can be
          ["gmres"], "pcg" or "bicgstab".

     Restart
          restart parameter for the GMRES solver (ignored for other
          solvers).  [Default = 20].

     The function typically returns two outputs.  Variable T is a column
     vector and contains the times where the solution was found.  The
     output Y is a matrix in which each column refers to a different
     unknown of the problem and each row corresponds to a time in T.

     The output can also be returned as a structure SOLUTION which has
     field X containing the time where the solution was evaluated and
     field Y containing the solution matrix for the times in X.  Use
     'fieldnames (SOLUTION)' to see the other fields and additional
     information returned.

     If using the '"Events"' option then three additional outputs may be
     returned.  TE holds the time when an Event function returned a
     zero.  YE holds the value of the solution at time TE.  IE contains
     an index indicating which Event function was triggered in the case
     of multiple Event functions.

     References:

     [1] S.C. Eisenstat and H.F. Walker, "Choosing the Forcing Terms in
     an Inexact Newton Method."  SIAM Journal on Scientific Computing,
     17(1), pp.  16-16, 1996.

     See also: odeset, odefwe, inexact_newton.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
This function is a geometric integrator for Hamilton's equations of
motion that 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
odeSV


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4838
 -- Function File: [T, Y] = odeSV (FUN, TRANGE, INIT)
 -- Function File: [T, Y] = odeSV (FUN, TRANGE, INIT, ODE_OPT)
 -- Function File: [T, Y] = odeSV (..., PAR1, PAR2, ...)
 -- Function File: [T, Y, TE, YE, IE] = odeSV (...)
 -- Function File: SOLUTION = odeSV (...)

     This function is a geometric integrator for Hamilton's equations of
     motion that uses the Stormer-Verlet method of order 2.

     FUN is a function_handle or an inline function that defines the
     system q' = dH/dp (t,[q;p]) p' = -dH/dq (t,[q;p]), where H(t,[q;p])
     is the Hamiltonian of the problem, q are generalized coordinates
     and p are generalized momenta.  This function must take two input
     arguments: the time and the unknowns.  It must return a vector or a
     cell (if the Hamiltonian Hessian is passed to speedup computations)
     containing as first element the Hamilton's equations of motion (the
     previous system of equations) and as second element the Hessian of
     the Hamiltonian.

     TRANGE specifies the time interval over which the ODE will be
     evaluated.  Typically, it is a two-element vector specifying the
     initial and final times ('[tinit, tfinal]').  If there are more
     than two elements then the solution will also be evaluated at these
     intermediate time instances using quadratic interpolation.

     By default, 'odeSE' uses an adaptive timestep with the
     'integrate_adaptive' algorithm.  The tolerance for the timestep
     computation may be changed by using the options '"RelTol"' and
     '"AbsTol"'.

     INIT contains the initial value for the unknowns.  It is a row or
     column vector containing the generalized coordinates in its first
     half and the generalized momenta in the second half.  Each momentum
     correspond to the coordinate with the same relative position inside
     the vector of initial conditions.

     The optional fourth argument ODE_OPT specifies non-default options
     to the ODE solver.  It is a structure generated by 'odeset'.
     'ode12' will ignore the following options: "BDF", "InitialSlope",
     "Jacobian", "JPattern", "MassSingular", "MaxOrder", "MvPattern",
     "Vectorized".  The user can set extra options by adding fields to
     the structure.  'odeSV' allows for:

     NewtonTol
          the tolerance for the Newton algorithm [Default = 1e-7].

     MaxNewtonIterations
          maximum number of Newton iterations [Default = 100].

     InexactSolver
          the Newton solver.  It can be set to either
          ["newton_raphson"], "inexact_newton" or "fsolve".

     Explicit
          It can be set to either "yes" or ["no].  If the system is
          explicit, the computation will be faster

     If the "inexact_newton" solver is set, a further set of options can
     be provided:

     UseJacobian
          It can be set to either "yes" or ["no].  In the first case,
          the Hamiltonian Hessian, the constraint gradient and the
          constraint Hessian will be used.  If they are not provided,
          they will be approximated by the utility functions
          'approx_Hamilt_Hess', 'approx_Constr_grad' and
          'approx_Constr_Hess'.

     Eta
          initial forcing term (must be in the interval [0,1)).  The
          dafault value is set to 0.5.  For details see [1].

     Choice
          select the forcing term.  It can be 1 (Default) or 2.  For
          details see [1].

     Algorithm
          iterative method to solve the linearized system.  It can be
          ["gmres"], "pcg" or "bicgstab".

     Restart
          restart parameter for the GMRES solver (ignored for other
          solvers).  [Default = 20].

     The function typically returns two outputs.  Variable T is a column
     vector and contains the times where the solution was found.  The
     output Y is a matrix in which each column refers to a different
     unknown of the problem and each row corresponds to a time in T.

     The output can also be returned as a structure SOLUTION which has
     field X containing the time where the solution was evaluated and
     field Y containing the solution matrix for the times in X.  Use
     'fieldnames (SOLUTION)' to see the other fields and additional
     information returned.

     If using the '"Events"' option then three additional outputs may be
     returned.  TE holds the time when an Event function returned a
     zero.  YE holds the value of the solution at time TE.  IE contains
     an index indicating which Event function was triggered in the case
     of multiple Event functions.

     References:

     [1] S.C. Eisenstat and H.F. Walker, "Choosing the Forcing Terms in
     an Inexact Newton Method."  SIAM Journal on Scientific Computing,
     17(1), pp.  16-16, 1996.

     See also: odeset, odeRATTLE, odeSE, odeSPVI, odeVV.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
This function is a geometric integrator for Hamilton's equations of
motion that 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
odeVV


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4752
 -- Command: [SOL] = odeVV (@FUN, TRANGE, INIT, [OPT], [PAR1, PAR2,
          ...])
 -- Command: [T, Y, [XE, YE, IE]] = odeVV (@FUN, TRANGE, INIT, [OPT],
          [PAR1, PAR2, ...])

     This function is a geometric integrator for Newton's equations of
     motion that uses the Velocity-Verlet method of order 2.

     FUN is a function_handle or an inline function that defines the
     system q' = dH/dp (t,[q;p]) p' = -dH/dq (t,[q;p]), where H(t,[q;p])
     is the Hamiltonian of the problem, q are generalized coordinates
     and p are generalized momenta.  This function must take two input
     arguments: the time and the unknowns.  It must return a vector or a
     cell (if the Hamiltonian Hessian is passed to speedup computations)
     containing as first element the Hamilton's equations of motion (the
     previous system of equations) and as second element the Hessian of
     the Hamiltonian.

     TRANGE specifies the time interval over which the ODE will be
     evaluated.  Typically, it is a two-element vector specifying the
     initial and final times ('[tinit, tfinal]').  If there are more
     than two elements then the solution will also be evaluated at these
     intermediate time instances using quadratic interpolation.

     By default, 'odeVV' uses an adaptive timestep with the
     'integrate_adaptive' algorithm.  The tolerance for the timestep
     computation may be changed by using the options '"RelTol"' and
     '"AbsTol"'.

     INIT contains the initial value for the unknowns.  It is a row or
     column vector containing the generalized coordinates in its first
     half and the generalized momenta in the second half.  Each momentum
     correspond to the coordinate with the same relative position inside
     the vector of initial conditions.

     The optional fourth argument ODE_OPT specifies non-default options
     to the ODE solver.  It is a structure generated by 'odeset'.
     'ode12' will ignore the following options: "BDF", "InitialSlope",
     "Jacobian", "JPattern", "MassSingular", "MaxOrder", "MvPattern",
     "Vectorized".  The user can set extra options by adding fields to
     the structure.  'odeSV' allows for:

     NewtonTol
          the tolerance for the Newton algorithm [Default = 1e-7].

     MaxNewtonIterations
          maximum number of Newton iterations [Default = 100].

     InexactSolver
          the Newton solver.  It can be set to either
          ["newton_raphson"], "inexact_newton" or "fsolve".

     Explicit
          It can be set to either "yes" or ["no].  If the system is
          explicit, the computation will be faster

     If the "inexact_newton" solver is set, a further set of options can
     be provided:

     UseJacobian
          It can be set to either "yes" or ["no].  In the first case,
          the Hamiltonian Hessian, the constraint gradient and the
          constraint Hessian will be used.  If they are not provided,
          they will be approximated by the utility functions
          'approx_Hamilt_Hess', 'approx_Constr_grad' and
          'approx_Constr_Hess'.

     Eta
          initial forcing term (must be in the interval [0,1)).  The
          dafault value is set to 0.5.  For details see [1].

     Choice
          select the forcing term.  It can be 1 (Default) or 2.  For
          details see [1].

     Algorithm
          iterative method to solve the linearized system.  It can be
          ["gmres"], "pcg" or "bicgstab".

     Restart
          restart parameter for the GMRES solver (ignored for other
          solvers).  [Default = 20].

     The function typically returns two outputs.  Variable T is a column
     vector and contains the times where the solution was found.  The
     output Y is a matrix in which each column refers to a different
     unknown of the problem and each row corresponds to a time in T.

     The output can also be returned as a structure SOLUTION which has
     field X containing the time where the solution was evaluated and
     field Y containing the solution matrix for the times in X.  Use
     'fieldnames (SOLUTION)' to see the other fields and additional
     information returned.

     If using the '"Events"' option then three additional outputs may be
     returned.  TE holds the time when an Event function returned a
     zero.  YE holds the value of the solution at time TE.  IE contains
     an index indicating which Event function was triggered in the case
     of multiple Event functions.

     References:

     [1] S.C. Eisenstat and H.F. Walker, "Choosing the Forcing Terms in
     an Inexact Newton Method."  SIAM Journal on Scientific Computing,
     17(1), pp.  16-16, 1996.

     See also: odeset, odeRATTLE, odeSE, odeSPVI, odeSV.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
This function is a geometric integrator for Newton's equations of motion
that us



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
odebwe


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4010
 -- Function File: [T, Y] = odebwe (FUN, TRANGE, INIT)
 -- Function File: [T, Y] = odebwe (FUN, TRANGE, INIT, ODE_OPT)
 -- Function File: [T, Y] = odebwe (..., PAR1, PAR2, ...)
 -- Function File: [T, Y, TE, YE, IE] = odebwe (...)
 -- Function File: SOLUTION = odebwe (...)

     Solve a set of Ordinary Differential Equations with the well known
     implicit Backward-Euler method of order 1.  The method is indicated
     both for stiff and non-stiff problems.

     FUN is a function handle, inline function, or string containing the
     name of the function that defines the ODE: 'y' = f(t,y)'.  The
     function must accept two inputs where the first is time T and the
     second is a column vector of unknowns Y.

     TRANGE specifies the time interval over which the ODE will be
     evaluated.  Typically, it is a two-element vector specifying the
     initial and final times ('[tinit, tfinal]').  If there are more
     than two elements then the solution will also be evaluated at these
     intermediate time instances using linear interpolation.

     INIT contains the initial value for the unknowns.  If it is a row
     vector then the solution Y will be a matrix in which each column is
     the solution for the corresponding initial value in INIT.

     The optional fourth argument ODE_OPT specifies non-default options
     to the ODE solver.  It is a structure generated by 'odeset'.
     'odebwe' will ignore the following options: "BDF", "InitialSlope",
     "MassSingular", "MaxOrder", "MvPattern", "NonNegative".  The user
     can set extra options by adding fields to the structure.  'odebwe'
     allows for:

     NewtonTol
          the tolerance for the Newton algorithm [Default = 1e-7].

     MaxNewtonIterations
          maximum number of Newton iterations [Default = 100].

     InexactSolver
          the Newton solver.  It can be set to either
          ["newton_raphson"], "inexact_newton" or "fsolve".

     If the "inexact_newton" solver is set, a further set of options can
     be provided:

     UseJacobian
          specify if the Jacobian information should be used.  It can be
          set to either "yes" or ["no].

     Eta
          initial forcing term (must be in the interval [0,1)).  The
          dafault value is set to 0.5.  For details see [1].

     Choice
          select the forcing term.  It can be 1 (Default) or 2.  For
          details see [1].

     Algorithm
          iterative method to solve the linearized system.  It can be
          ["gmres"], "pcg" or "bicgstab".

     Restart
          restart parameter for the GMRES solver (ignored for other
          solvers).  [Default = 20].

     The function typically returns two outputs.  Variable T is a column
     vector and contains the times where the solution was found.  The
     output Y is a matrix in which each column refers to a different
     unknown of the problem and each row corresponds to a time in T.

     The output can also be returned as a structure SOLUTION which has
     field X containing the time where the solution was evaluated and
     field Y containing the solution matrix for the times in X.  Use
     'fieldnames (SOLUTION)' to see the other fields and additional
     information returned.

     If using the '"Events"' option then three additional outputs may be
     returned.  TE holds the time when an Event function returned a
     zero.  YE holds the value of the solution at time TE.  IE contains
     an index indicating which Event function was triggered in the case
     of multiple Event functions.

     For example, solve an anonymous implementation of the Van der Pol
     equation

          fvdp = @(T,Y) [Y(2); (1 - Y(1)^2) * Y(2) - Y(1)];
          [T,Y] = odebwe (fvdp, [0, 2], [2, 0]);

     References:

     [1] S.C. Eisenstat and H.F. Walker, "Choosing the Forcing Terms in
     an Inexact Newton Method."  SIAM Journal on Scientific Computing,
     17(1), pp.  16-16, 1996.

     See also: odeset, odefwe, inexact_newton.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Solve a set of Ordinary Differential Equations with the well known
implicit Back



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
odeexamples


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 168
 -- Function File: [] = odeexamples ()

     Open the differential equations examples menu and allow the user to
     select a submenu of ODE, DAE, IDE or DDE examples.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Open the differential equations examples menu and allow the user to
select a sub



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
odefwe


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3032
 -- Function File: [T, Y] = odefwe (FUN, TRANGE, INIT)
 -- Function File: [T, Y] = odefwe (FUN, TRANGE, INIT, ODE_OPT)
 -- Function File: [T, Y] = odefwe (..., PAR1, PAR2, ...)
 -- Function File: [T, Y, TE, YE, IE] = odefwe (...)
 -- Function File: SOLUTION = odefwe (...)

     Solve a set of non-stiff Ordinary Differential Equations (non-stiff
     ODEs) with the well known explicit Forward-Euler method of order 1.

     FUN is a function handle, inline function, or string containing the
     name of the function that defines the ODE: 'y' = f(t,y)'.  The
     function must accept two inputs where the first is time T and the
     second is a column vector of unknowns Y.

     TRANGE specifies the time interval over which the ODE will be
     evaluated.  Typically, it is a two-element vector specifying the
     initial and final times ('[tinit, tfinal]').  If there are more
     than two elements then the solution will also be evaluated at these
     intermediate time instances using an interpolation procedure of the
     same order as the one of the solver.

     By default, 'odefwe' uses an adaptive timestep with the
     'integrate_adaptive' algorithm.  The tolerance for the timestep
     computation may be changed by using the options '"RelTol"' and
     '"AbsTol"'.

     INIT contains the initial value for the unknowns.  If it is a row
     vector then the solution Y will be a matrix in which each column is
     the solution for the corresponding initial value in INIT.

     The optional fourth argument ODE_OPT specifies non-default options
     to the ODE solver.  It is a structure generated by 'odeset'.
     'odefwe' will ignore the following options: "BDF", "InitialSlope",
     "Jacobian", "JPattern", "MassSingular", "MaxOrder", "MvPattern",
     "Vectorized".

     The function typically returns two outputs.  Variable T is a column
     vector and contains the times where the solution was computed.  The
     output Y is a matrix in which each column refers to a different
     unknown of the problem and each row corresponds to a time in T.  If
     TRANGE specifies intermediate time steps, only those will be
     returned.

     The output can also be returned as a structure SOLUTION which has a
     field X containing a row vector of times where the solution was
     evaluated and a field Y containing the solution matrix such that
     each column corresponds to a time in X.  Use 'fieldnames
     (SOLUTION)' to see the other fields and additional information
     returned.

     If using the '"Events"' option then three additional outputs may be
     returned.  TE holds the time when an Event function returned a
     zero.  YE holds the value of the solution at time TE.  IE contains
     an index indicating which Event function was triggered in the case
     of multiple Event functions.

     Example: Solve the Van der Pol equation

          fvdp = @(T,Y) [Y(2); (1 - Y(1)^2) * Y(2) - Y(1)];
          [T,Y] = odefwe (fvdp, [0 20], [2 0]);

     See also: odeset, odebwe.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Solve a set of non-stiff Ordinary Differential Equations (non-stiff
ODEs) with t



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
odephas2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1611
 -- Function File: [RET] = odephas2 (T, Y, FLAG)

     Open a new figure window and plot the first result from the
     variable Y that is of type double column vector over the second
     result from the variable Y while solving.  The types and the values
     of the input parameter T and the output parameter RET depend on the
     input value FLAG that is of type string.  If FLAG is

     '"init"'
          then T must be a double column vector of length 2 with the
          first and the last time step and nothing is returned from this
          function.

     '""'
          then T must be a double scalar specifying the actual time step
          and the return value is false (resp.  value 0) for 'not stop
          solving'.

     '"done"'
          then T must be a double scalar specifying the last time step
          and nothing is returned from this function.

     This function is called by a OdePkg solver function if it was
     specified in an OdePkg options structure with the 'odeset'.  This
     function is an OdePkg internal helper function therefore it should
     never be necessary that this function is called directly by a user.
     There is only little error detection implemented in this function
     file to achieve the highest performance.

     Example: Solve the Van der Pol equation and display the results
     while solving in a 2D plane
          fvdb = @(vt,vy) [vy(2); (1 - vy(1)^2) * vy(2) - vy(1)];

          vopt = odeset ('OutputFcn', @odephas2, 'RelTol', 1e-6);
          vsol = ode45 (fvdb, [0 20], [2 0], vopt);

     See also: odeset, odeplot, odephas3.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Open a new figure window and plot the first result from the variable Y
that is o



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
odephas3


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1743
 -- Function File: [RET] = odephas3 (T, Y, FLAG)

     Open a new figure window and plot the first result from the
     variable Y that is of type double column vector over the second and
     the third result from the variable Y while solving.  The types and
     the values of the input parameter T and the output parameter RET
     depend on the input value FLAG that is of type string.  If FLAG is

     '"init"'
          then T must be a double column vector of length 2 with the
          first and the last time step and nothing is returned from this
          function.

     '""'
          then T must be a double scalar specifying the actual time step
          and the return value is false (resp.  value 0) for 'not stop
          solving'.

     '"done"'
          then T must be a double scalar specifying the last time step
          and nothing is returned from this function.

     This function is called by a OdePkg solver function if it was
     specified in an OdePkg options structure with the 'odeset'.  This
     function is an OdePkg internal helper function therefore it should
     never be necessary that this function is called directly by a user.
     There is only little error detection implemented in this function
     file to achieve the highest performance.

     Example: Solve the Van der Pol equation and display the results
     while solving in a 3D plane
          function vyd = florenz (vt, vx)
            vyd = [10 * (vx(2) - vx(1));
                   vx(1) * (28 - vx(3));
                   vx(1) * vx(2) - 8/3 * vx(3)];
          end

          vopt = odeset ('OutputFcn', @odephas3);
          vsol = ode23 (@florenz, [0:0.01:7.5], [3 15 1], vopt);

     See also: odeset, odeplot, odephas2.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Open a new figure window and plot the first result from the variable Y
that is o



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
odepkg


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 667
 -- Function File: [] = odepkg ()

     OdePkg is part of the GNU Octave Repository (the Octave-Forge
     project).  The package includes commands for setting up various
     options, output functions etc.  before solving a set of
     differential equations with the solver functions that are also
     included.  At this time OdePkg is under development with the main
     target to make a package that is mostly compatible to proprietary
     solver products.

     If this function is called without any input argument then open the
     OdePkg tutorial in the Octave window.  The tutorial can also be
     opened with the following command

          doc odepkg


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 71
OdePkg is part of the GNU Octave Repository (the Octave-Forge project).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 19
odepkg_examples_dae


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 143
 -- Function File: [] = odepkg_examples_dae ()
     Open the DAE examples menu and allow the user to select a demo that
     will be evaluated.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Open the DAE examples menu and allow the user to select a demo that will
be eval



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 19
odepkg_examples_dde


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 143
 -- Function File: [] = odepkg_examples_dde ()
     Open the DDE examples menu and allow the user to select a demo that
     will be evaluated.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Open the DDE examples menu and allow the user to select a demo that will
be eval



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 19
odepkg_examples_ide


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 143
 -- Function File: [] = odepkg_examples_ide ()
     Open the IDE examples menu and allow the user to select a demo that
     will be evaluated.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Open the IDE examples menu and allow the user to select a demo that will
be eval



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 19
odepkg_examples_ode


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 143
 -- Function File: [] = odepkg_examples_ode ()
     Open the ODE examples menu and allow the user to select a demo that
     will be evaluated.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Open the ODE examples menu and allow the user to select a demo that will
be eval



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
odepkg_testsuite_calcmescd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 888
 -- Function File: [MESCD] = odepkg_testsuite_calcmescd (SOLUTION,
          REFERENCE, ABSTOL, RELTOL)

     If this function is called with four input arguments of type double
     scalar or column vector then return a normalized value for the
     minimum number of correct digits MESCD that is calculated from the
     solution at the end of an integration interval SOLUTION and a set
     of reference values REFERENCE.  The input arguments ABSTOL and
     RELTOL are used to calculate a reference solution that depends on
     the relative and absolute error tolerances.

     Run examples with the command
          demo odepkg_testsuite_calcmescd

     This function has been ported from the "Test Set for IVP solvers"
     which is developed by the INdAM Bari unit project group "Codes and
     Test Problems for Differential Equations", coordinator F. Mazzia.

See also: odepkg.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
If this function is called with four input arguments of type double
scalar or co



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
odepkg_testsuite_calcscd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 871
 -- Function File: [SCD] = odepkg_testsuite_calcscd (SOLUTION,
          REFERENCE, ABSTOL, RELTOL)

     If this function is called with four input arguments of type double
     scalar or column vector then return a normalized value for the
     minimum number of correct digits SCD that is calculated from the
     solution at the end of an integration interval SOLUTION and a set
     of reference values REFERENCE.  The input arguments ABSTOL and
     RELTOL are unused but present because of compatibility to the
     function 'odepkg_testsuite_calcmescd'.

     Run examples with the command
          demo odepkg_testsuite_calcscd

     This function has been ported from the "Test Set for IVP solvers"
     which is developed by the INdAM Bari unit project group "Codes and
     Test Problems for Differential Equations", coordinator F. Mazzia.

See also: odepkg.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
If this function is called with four input arguments of type double
scalar or co



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 25
odepkg_testsuite_chemakzo


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 831
 -- Function File: [SOLUTION] = odepkg_testsuite_chemakzo (@SOLVER,
          RELTOL)

     If this function is called with two input arguments and the first
     input argument @SOLVER is a function handle describing an OdePkg
     solver and the second input argument RELTOL is a double scalar
     describing the relative error tolerance then return a cell array
     SOLUTION with performance information about the chemical AKZO Nobel
     testsuite of differential algebraic equations after solving
     (DAE-test).

     Run examples with the command
          demo odepkg_testsuite_chemakzo

     This function has been ported from the "Test Set for IVP solvers"
     which is developed by the INdAM Bari unit project group "Codes and
     Test Problems for Differential Equations", coordinator F. Mazzia.

See also: odepkg.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
If this function is called with two input arguments and the first input
argument



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
odepkg_testsuite_hires


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 795
 -- Function File: [SOLUTION] = odepkg_testsuite_hires (@SOLVER, RELTOL)

     If this function is called with two input arguments and the first
     input argument @SOLVER is a function handle describing an OdePkg
     solver and the second input argument RELTOL is a double scalar
     describing the relative error tolerance then return a cell array
     SOLUTION with performance information about the HIRES testsuite of
     ordinary differential equations after solving (ODE-test).

     Run examples with the command
          demo odepkg_testsuite_hires

     This function has been ported from the "Test Set for IVP solvers"
     which is developed by the INdAM Bari unit project group "Codes and
     Test Problems for Differential Equations", coordinator F. Mazzia.

See also: odepkg.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
If this function is called with two input arguments and the first input
argument



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 25
odepkg_testsuite_implakzo


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 840
 -- Function File: [SOLUTION] = odepkg_testsuite_implakzo (@SOLVER,
          RELTOL)

     If this function is called with two input arguments and the first
     input argument @SOLVER is a function handle describing an OdePkg
     solver and the second input argument RELTOL is a double scalar
     describing the relative error tolerance then return a cell array
     SOLUTION with performance information about the chemical AKZO Nobel
     testsuite of implicit differential algebraic equations after
     solving (IDE-test).

     Run examples with the command
          demo odepkg_testsuite_implakzo

     This function has been ported from the "Test Set for IVP solvers"
     which is developed by the INdAM Bari unit project group "Codes and
     Test Problems for Differential Equations", coordinator F. Mazzia.

See also: odepkg.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
If this function is called with two input arguments and the first input
argument



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
odepkg_testsuite_implrober


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 862
 -- Function File: [SOLUTION] = odepkg_testsuite_implrober (@SOLVER,
          RELTOL)

     If this function is called with two input arguments and the first
     input argument @SOLVER is a function handle describing an OdePkg
     solver and the second input argument RELTOL is a double scalar
     describing the relative error tolerance then return a cell array
     SOLUTION with performance information about the implicit form of
     the modified ROBERTSON testsuite of implicit differential algebraic
     equations after solving (IDE-test).

     Run examples with the command
          demo odepkg_testsuite_implrober

     This function has been ported from the "Test Set for IVP solvers"
     which is developed by the INdAM Bari unit project group "Codes and
     Test Problems for Differential Equations", coordinator F. Mazzia.

See also: odepkg.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
If this function is called with two input arguments and the first input
argument



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
odepkg_testsuite_impltrans


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 835
 -- Function File: [SOLUTION] = odepkg_testsuite_impltrans (@SOLVER,
          RELTOL)

     If this function is called with two input arguments and the first
     input argument @SOLVER is a function handle describing an OdePkg
     solver and the second input argument RELTOL is a double scalar
     describing the relative error tolerance then return the cell array
     SOLUTION with performance information about the TRANSISTOR
     testsuite of implicit differential algebraic equations after
     solving (IDE-test).

     Run examples with the command
          demo odepkg_testsuite_impltrans

     This function has been ported from the "Test Set for IVP solvers"
     which is developed by the INdAM Bari unit project group "Codes and
     Test Problems for Differential Equations", coordinator F. Mazzia.

See also: odepkg.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
If this function is called with two input arguments and the first input
argument



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 27
odepkg_testsuite_oregonator


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 825
 -- Function File: [SOLUTION] = odepkg_testsuite_oregonator (@SOLVER,
          RELTOL)

     If this function is called with two input arguments and the first
     input argument @SOLVER is a function handle describing an OdePkg
     solver and the second input argument RELTOL is a double scalar
     describing the relative error tolerance then return a cell array
     SOLUTION with performance information about the OREGONATOR
     testsuite of ordinary differential equations after solving
     (ODE-test).

     Run examples with the command
          demo odepkg_testsuite_oregonator

     This function has been ported from the "Test Set for IVP solvers"
     which is developed by the INdAM Bari unit project group "Codes and
     Test Problems for Differential Equations", coordinator F. Mazzia.

See also: odepkg.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
If this function is called with two input arguments and the first input
argument



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
odepkg_testsuite_pollution


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 819
 -- Function File: [SOLUTION] = odepkg_testsuite_pollution (@SOLVER,
          RELTOL)

     If this function is called with two input arguments and the first
     input argument @SOLVER is a function handle describing an OdePkg
     solver and the second input argument RELTOL is a double scalar
     describing the relative error tolerance then return the cell array
     SOLUTION with performance information about the POLLUTION testsuite
     of ordinary differential equations after solving (ODE-test).

     Run examples with the command
          demo odepkg_testsuite_pollution

     This function has been ported from the "Test Set for IVP solvers"
     which is developed by the INdAM Bari unit project group "Codes and
     Test Problems for Differential Equations", coordinator F. Mazzia.

See also: odepkg.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
If this function is called with two input arguments and the first input
argument



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
odepkg_testsuite_robertson


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 832
 -- Function File: [SOLUTION] = odepkg_testsuite_robertson (@SOLVER,
          RELTOL)

     If this function is called with two input arguments and the first
     input argument @SOLVER is a function handle describing an OdePkg
     solver and the second input argument RELTOL is a double scalar
     describing the relative error tolerance then return a cell array
     SOLUTION with performance information about the modified ROBERTSON
     testsuite of differential algebraic equations after solving
     (DAE-test).

     Run examples with the command
          demo odepkg_testsuite_robertson

     This function has been ported from the "Test Set for IVP solvers"
     which is developed by the INdAM Bari unit project group "Codes and
     Test Problems for Differential Equations", coordinator F. Mazzia.

See also: odepkg.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
If this function is called with two input arguments and the first input
argument



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 27
odepkg_testsuite_transistor


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 828
 -- Function File: [SOLUTION] = odepkg_testsuite_transistor (@SOLVER,
          RELTOL)

     If this function is called with two input arguments and the first
     input argument @SOLVER is a function handle describing an OdePkg
     solver and the second input argument RELTOL is a double scalar
     describing the relative error tolerance then return the cell array
     SOLUTION with performance information about the TRANSISTOR
     testsuite of differential algebraic equations after solving
     (DAE-test).

     Run examples with the command
          demo odepkg_testsuite_transistor

     This function has been ported from the "Test Set for IVP solvers"
     which is developed by the INdAM Bari unit project group "Codes and
     Test Problems for Differential Equations", coordinator F. Mazzia.

See also: odepkg.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
If this function is called with two input arguments and the first input
argument



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
odeprint


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1703
 -- Function File: [RET] = odeprint (T, Y, FLAG)

     Display the results of the set of differential equations in the
     Octave window while solving.  The first column of the screen output
     shows the actual time stamp that is given with the input arguemtn
     T, the following columns show the results from the function
     evaluation that are given by the column vector Y.  The types and
     the values of the input parameter T and the output parameter RET
     depend on the input value FLAG that is of type string.  If FLAG is

     '"init" then T must be a double column vector of length 2'
          with the first and thelast time step and nothing is returned
          from this function,

     '""'
          then T must be a double scalar specifying the actual time step
          and the return value is false (resp.  value 0) for 'not stop
          solving',

     '"done" then T must be a double scalar specifying the'
          last time step and nothing is returned from this function.

     This function is called by a OdePkg solver function if it was
     specified in an OdePkg options structure with the 'odeset'.  This
     function is an OdePkg internal helper function therefore it should
     never be necessary that this function is called directly by a user.
     There is only little error detection implemented in this function
     file to achieve the highest performance.

     Example: Solve the Van der Pol equation and print the results while
     solving

          fvdb = @(vt,vy) [vy(2); (1 - vy(1)^2) * vy(2) - vy(1)];
          vopt = odeset ('OutputFcn', @odeprint, 'RelTol', 1e-6);
          vsol = ode45 (fvdb, [0 20], [2 0], vopt);

See also: odeplot.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Display the results of the set of differential equations in the Octave
window wh



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
rattle


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1960
 -- Command: [T_NEXT, X_NEXT] = rattle (@FUN, T, X, DT, [OPTIONS])
 -- Command: [T_NEXT, X_NEXT, X_EST] = rattle (@FUN, T, X, DT,
          [OPTIONS])

     This function can be used to integrate a constrained Hamiltonian
     system with a given initial condition X from T to T+DT, with the
     RATTLE method using the Richardson extrapolation method to estimate
     the error.  For details about this method see [1].

     First output argument is the final integration time value.

     Second output parameter is the computed solution at time T_NEXT.

     Third output parameter is a higher order solution for the
     estimation of the error.

     First input argument is the function describing the system of ODEs
     to be integrated.

     Second input parameter is the first extreme of integration
     interval.

     Third input argument is the initial condition of the system.

     Fourth input argument is the timestep, that is the length of the
     integration interval.

     Fifth input parameter is optional and describes a set of options
     useful to adapt the computation to what is needed.  Possible fields
     are
     'HamiltonianHessFcn'
          a function_handle that represents the Hessian of the
          Hamiltonian of the system,
     'ConstraintFcn'
          a function_handle that represents the constraints of the
          system,
     'ConstraintsNb'
          a positive integer equal to the number of constraints of the
          system,
     'ConstraintGradFcn'
          a function_handle that represents the gradient of the
          constraints of the system,
     'ConstraintHessFcn'
          a function_handle that represents the Hessian of the
          constraints of the system.

     References: [1] E. Hairer, C. Lubich and G. Wanner, "Geometric
     Numerical Integration: Structure-Preserving Algorithms for Ordinary
     Differential Equations."  Second Edition, Springer.

     See also: odepkg.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
This function can be used to integrate a constrained Hamiltonian system
with a g



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
runge_kutta_23s


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1933
 -- [T_NEXT, X_NEXT] = runge_kutta_23s (F, T, X, DT)
 -- [T_NEXT, X_NEXT] = runge_kutta_23s (F, T, X, DT, OPTIONS)
 -- [T_NEXT, X_NEXT] = runge_kutta_23s (F, T, X, DT, OPTIONS,
          K_VALS_IN)
 -- [T_NEXT, X_NEXT] = runge_kutta_23s (F, T, X, DT, OPTIONS,
          K_VALS_IN, T_NEXT)
 -- [T_NEXT, X_NEXT, X_EST] = runge_kutta_23s (...)
 -- [T_NEXT, X_NEXT, X_EST, K_VALS_OUT] = runge_kutta_23s (...)

     This function can be used to integrate a system of ODEs with a
     given initial condition X from T to T+DT, with a Rosenbrock method
     of order (2,3).  All the mathematical formulas are from "The MATLAB
     ode suite", L.F. Shampine, options.Mass.W. Reichelt, pp.6-71.

     F is a function handle that defines the ODE: 'y' = f(tau,y)'.  The
     function must accept two inputs where the first is time TAU and the
     second is a column vector of unknowns Y.

     T is the first extreme of integration interval.

     X is the initial condition of the system..

     DT is the timestep, that is the length of the integration interval.

     The optional fourth argument OPTIONS specifies options for the ODE
     solver.  It is a structure generated by 'odeset'.  In particular it
     contains the field FUNARGUMENTS with the optional arguments to be
     used in the evaluation of F.

     The optional fifth argument K_VALS_IN contains the Runge-Kutta
     evaluations of the previous step to use in a FSAL scheme.

     The optional sixth argument T_NEXT ('t_next = t + dt') specifies
     the end of the integration interval.  The output X_NEXT s the
     higher order computed solution at time T_NEXT (local extrapolation
     is performed).

     Optionally the functions can also return X_EST, a lower order
     solution for the estimation of the error, and K_VALS_OUT, a matrix
     containing the Runge-Kutta evaluations to use in a FSAL scheme or
     for dense output.

     See also: runge_kutta_23.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
This function can be used to integrate a system of ODEs with a given
initial con



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
runge_kutta_45_fehlberg


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1168
 -- Command: [T_NEXT, X_NEXT] = runge_kutta_45_fehlberg (@FUN, T, X, DT,
          [OPTIONS])
 -- Command: [T_NEXT, X_NEXT, X_EST] = runge_kutta_45_fehlberg (@FUN, T,
          X, DT, [OPTIONS])

     This function can be used to integrate a system of ODEs with a
     given initial condition X from T to T+DT, with the Fehlberg method.
     For the definition of this method see
     <http://en.wikipedia.org/wiki/Dormand%E2%80%93Prince_method>.

     First output argument is the final integration time value.

     Second output parameter is the computed solution at time T_NEXT.

     Third output parameter is a higher order solution for the
     estimation of the error.

     First input argument is the function describing the system of ODEs
     to be integrated.

     Second input parameter is the first extreme of integration
     interval.

     Third input argument is the initial condition of the system.

     Fourth input argument is the timestep, that is the length of the
     integration interval.

     Fifth input parameter is optional and describes a set of options
     useful to adapt the computation to what is needed.

     See also: odepkg.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
This function can be used to integrate a system of ODEs with a given
initial con



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
runge_kutta_78


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1084
 -- Command: [T_NEXT, X_NEXT] = runge_kutta_78 (@FUN, T, X, DT,
          [OPTIONS])
 -- Command: [T_NEXT, X_NEXT, X_EST] = runge_kutta_78 (@FUN, T, X, DT,
          [OPTIONS])

     This function can be used to integrate a system of ODEs with a
     given initial condition X from T to T+DT.  For the definition of
     this method see p.91 in Ascher & Petzold.

     First output argument is the final integration time value.

     Second output parameter is the computed solution at time T_NEXT.

     Third output parameter is a higher order solution for the
     estimation of the error.

     First input argument is the function describing the system of ODEs
     to be integrated.

     Second input parameter is the first extreme of integration
     interval.

     Third input argument is the initial condition of the system.

     Fourth input argument is the timestep, that is the length of the
     integration interval.

     Fifth input parameter is optional and describes a set of options
     useful to adapt the computation to what is needed.

     See also: odepkg.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
This function can be used to integrate a system of ODEs with a given
initial con



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
spectral_var_int


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3318
 -- Command: [T_NEXT, X_NEXT] = spectral_var_int (@FUN, T, X, DT,
          [OPTIONS])
 -- Command: [T_NEXT, X_NEXT, X_EST] = spectral_var_int (@FUN, T, X, DT,
          [OPTIONS])

     This function can be used to integrate a Hamiltonian system with a
     given initial condition X from T to T+DT, with the spectral
     variational integrators method.  The error is estimated comparing
     the solution with that one obtained with the same method but one
     order higher polynomials and one degree higher quadrature rule.
     For details about the theory see [1].

     First output argument is the final integration time value.

     Second output parameter is the computed solution at time T_NEXT.

     Third output parameter is a higher order solution for the
     estimation of the error.

     First input argument is the function describing the system of ODEs
     to be integrated.

     Second input parameter is the first extreme of integration
     interval.

     Third input argument is the initial condition of the system.

     Fourth input argument is the timestep, that is the length of the
     integration interval.

     Fifth input parameter is optional and describes a set of options
     useful to adapt the computation to what is needed.  The possible
     fields are
     'HamiltonianHessFcn'
          a function_handle that represents the Hessian of the
          Hamiltonian of the system,
     'Q_DoFs'
          a positive integer equal to Gauss quadrature rule degrees of
          freedom,
     'P_DoFs'
          a positive integer equal to Legendre polynomial degrees of
          freedom,
     'Nodes'
          a vector containing Gauss quadrature nodes,
     'Weights'
          a vector containing Gauss quadrature weights,
     'Legendre'
          a matrix containing Legendre polynomials values at quadrature
          nodes,
     'Derivatives'
          a matrix containing derivatives of Legendre polynomials
          evaluated at quadrature nodes,
     'Extremes'
          a matrix containing Legendre polynomials values at extremes,
     'Q_DoFs_err'
          a positive integer equal to Gauss quadrature rule degrees of
          freedom for the solution used to estimate the error,
     'P_DoFs_err'
          a positive integer equal to Legendre polynomial degrees of
          freedom for the solution used to estimate the error,
     'Nodes_err'
          a vector containing Gauss quadrature nodes for the solution
          used to estimate the error,
     'Weights_err'
          a vector containing Gauss quadrature weights for the solution
          used to estimate the error,
     'Legendre_err'
          a matrix containing Legendre polynomials values at quadrature
          nodes for the solution used to estimate the error,
     'Derivatives_err'
          a matrix containing derivatives of Legendre polynomials
          evaluated at quadrature nodes for the solution used to
          estimate the error,
     'Extremes_err'
          a matrix containing Legendre polynomials values at extremes
          for the solution used to estimate the error.

     References: [1] J.E. Marsden and M. West, "Discrete Mechanics and
     Variational Integrators."  Acta Numerica (2001), pp 1-158,
     Cambridge University Press.

     See also: odepkg.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
This function can be used to integrate a Hamiltonian system with a given
initial



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
stormer_verlet


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1647
 -- Command: [T_NEXT, X_NEXT] = stormer_verlet (@FUN, T, X, DT,
          [OPTIONS])
 -- Command: [T_NEXT, X_NEXT, X_EST] = stormer_verlet (@FUN, T, X, DT,
          [OPTIONS])

     This function can be used to integrate a Hamiltonian system with a
     given initial condition X from T to T+DT, with the Stormer-Verlet
     method using the Richardson extrapolation method to estimate the
     error.  For details about this method see [1].

     First output argument is the final integration time value.

     Second output parameter is the computed solution at time T_NEXT.

     Third output parameter is a higher order solution for the
     estimation of the error.

     First input argument is the function describing the system of ODEs
     to be integrated.

     Second input parameter is the first extreme of integration
     interval.

     Third input argument is the initial condition of the system.

     Fourth input argument is the timestep, that is the length of the
     integration interval.

     Fifth input parameter is optional and describes a set of options
     useful to adapt the computation to what is needed.  The possible
     fields are
     'Explicit'
          a switch ['YES','NO'] which tells the solver if the system to
          be solved is explicit or not,
     'HamiltonianHessFcn'
          a function_handle that represents the Hessian of the
          Hamiltonian of the system.

     References: [1] E. Hairer, C. Lubich and G. Wanner, "Geometric
     Numerical Integration: Structure-Preserving Algorithms for Ordinary
     Differential Equations."  Second Edition, Springer.

     See also: odepkg.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
This function can be used to integrate a Hamiltonian system with a given
initial



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
symplectic_euler


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1852
 -- Command: [T_NEXT, X_NEXT] = symplectic_euler (@FUN, T, X, DT,
          [OPTIONS])
 -- Command: [T_NEXT, X_NEXT, X_EST] = symplectic_euler (@FUN, T, X, DT,
          [OPTIONS])

     This function can be used to integrate a Hamiltonian system with a
     given initial condition X from T to T+DT, with the Symplectic Euler
     method (also known as Semi-implicit Euler) using the Richardson
     extrapolation method to estimate the error.  For details about this
     method see E. Hairer and C. Lubich and G. Wanner, "Geometric
     Numerical Integration: Structure-Preserving Algorithms for Ordinary
     Differential Equations", Springer.

     First output argument is the final integration time value.

     Second output parameter is the computed solution at time T_NEXT.

     Third output parameter is a higher order solution for the
     estimation of the error.

     First input argument is the function describing the system of ODEs
     to be integrated.

     Second input parameter is the first extreme of integration
     interval.

     Third input argument is the initial condition of the system.

     Fourth input argument is the timestep, that is the length of the
     integration interval.

     Fifth input parameter is optional and describes a set of options
     useful to adapt the computation to what is needed.  The possible
     fields are
     'Explicit'
          a switch ['YES','NO'] which tells the solver if the system to
          be solved is explicit or not,
     'HamiltonianHessFcn'
          a function_handle that represents the Hessian of the
          Hamiltonian of the system.

     References: [1] E. Hairer, C. Lubich and G. Wanner, "Geometric
     Numerical Integration: Structure-Preserving Algorithms for Ordinary
     Differential Equations."  Second Edition, Springer.

     See also: odepkg.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
This function can be used to integrate a Hamiltonian system with a given
initial



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
velocity_verlet


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1647
 -- Command: [T_NEXT, X_NEXT] = stormer_verlet (@FUN, T, X, DT,
          [OPTIONS])
 -- Command: [T_NEXT, X_NEXT, X_EST] = stormer_verlet (@FUN, T, X, DT,
          [OPTIONS])

     This function can be used to integrate a Hamiltonian system with a
     given initial condition X from T to T+DT, with the Stormer-Verlet
     method using the Richardson extrapolation method to estimate the
     error.  For details about this method see [1].

     First output argument is the final integration time value.

     Second output parameter is the computed solution at time T_NEXT.

     Third output parameter is a higher order solution for the
     estimation of the error.

     First input argument is the function describing the system of ODEs
     to be integrated.

     Second input parameter is the first extreme of integration
     interval.

     Third input argument is the initial condition of the system.

     Fourth input argument is the timestep, that is the length of the
     integration interval.

     Fifth input parameter is optional and describes a set of options
     useful to adapt the computation to what is needed.  The possible
     fields are
     'Explicit'
          a switch ['YES','NO'] which tells the solver if the system to
          be solved is explicit or not,
     'HamiltonianHessFcn'
          a function_handle that represents the Hessian of the
          Hamiltonian of the system.

     References: [1] E. Hairer, C. Lubich and G. Wanner, "Geometric
     Numerical Integration: Structure-Preserving Algorithms for Ordinary
     Differential Equations."  Second Edition, Springer.

     See also: odepkg.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
This function can be used to integrate a Hamiltonian system with a given
initial





